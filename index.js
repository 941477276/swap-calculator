!function(I){var g={};function n(l){if(g[l])return g[l].exports;var t=g[l]={i:l,l:!1,exports:{}};return I[l].call(t.exports,t,t.exports,n),t.l=!0,t.exports}n.m=I,n.c=g,n.d=function(I,g,l){n.o(I,g)||Object.defineProperty(I,g,{enumerable:!0,get:l})},n.r=function(I){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(I,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(I,"__esModule",{value:!0})},n.t=function(I,g){if(1&g&&(I=n(I)),8&g)return I;if(4&g&&"object"==typeof I&&I&&I.__esModule)return I;var l=Object.create(null);if(n.r(l),Object.defineProperty(l,"default",{enumerable:!0,value:I}),2&g&&"string"!=typeof I)for(var t in I)n.d(l,t,function(g){return I[g]}.bind(null,t));return l},n.n=function(I){var g=I&&I.__esModule?function(){return I.default}:function(){return I};return n.d(g,"a",g),g},n.o=function(I,g){return Object.prototype.hasOwnProperty.call(I,g)},n.p="",n(n.s=1)}([function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jc3MvaW5kZXguc2Nzcz8wODQ1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./src/css/index.scss\nvar css = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/js/util.js\nclass Precision {\n  // 乘法\n  times(num1, num2, ...others) {\n    if (others.length > 0) {\n      return this.times(this.times(num1, num2), ...others)\n    }\n    num1 = num1 || 0\n    num2 = num2 || 0\n    const num1Changed = this.float2Fixed(num1)\n    const num2Changed = this.float2Fixed(num2)\n    // 把两个数的小数位数相加\n    const baseNum = this.digitLength(num1) + this.digitLength(num2)\n    const leftValue = num1Changed * num2Changed\n    // this.checkBoundary(leftValue)\n    return leftValue / Math.pow(10, baseNum)\n  }\n// 精确加法\n  plus(num1, num2, ...others) {\n    if (others.length > 0) {\n      return this.plus(this.plus(num1, num2), ...others)\n    }\n    const baseNum = Math.pow(10, Math.max(this.digitLength(num1), this.digitLength(num2)))\n    return (this.times(num1, baseNum) + this.times(num2, baseNum)) / baseNum\n  }\n// 精确减法\n  minus(num1, num2, ...others) {\n    if (others.length > 0) {\n      return this.minus(this.minus(num1, num2), ...others)\n    }\n    const baseNum = Math.pow(10, Math.max(this.digitLength(num1), this.digitLength(num2)))\n    return (this.times(num1, baseNum) - this.times(num2, baseNum)) / baseNum\n  }\n// 精确除法\n  divide(num1, num2, ...others) {\n    if (others.length > 0) {\n      return this.divide(this.divide(num1, num2), ...others)\n    }\n    const num1Change = this.float2Fixed(num1)\n    const num2Change = this.float2Fixed(num2)\n    return this.times(num1Change / num2Change, Math.pow(10, this.digitLength(num2) - this.digitLength(num1)))\n  }\n  // 精确除法2\n  divide2(arg1, arg2) {\n    let t1 = 0\n    let t2 = 0\n    let r1, r2\n    try {\n      t1 = arg1.toString().split(\'.\')[1].length\n    } catch (e) {}\n    try {\n      t2 = arg2.toString().split(\'.\')[1].length\n    } catch (e) {}\n    r1 = Number(arg1.toString().replace(\'.\', \'\'))\n    r2 = Number(arg2.toString().replace(\'.\', \'\'))\n    return (r1 / r2) * Math.pow(10, t2 - t1)\n  }\n// 四舍五入，且保留小数\n  round(num, ratio) {\n    const base = Math.pow(10, ratio)\n    return this.divide(Math.round(this.times(num, base)), base)\n  }\n// 把小数转成整数，支持科学计数法。如果是小数则放大成整数\n  float2Fixed(num) {\n    if (!~num.toString().indexOf(\'e\')) {\n      return Number(num.toString().replace(\'.\', \'\'))\n    }\n    const dlen = this.digitLength(num)\n    return dlen > 0 ? num * Math.pow(10, dlen) : num\n  }\n// 获取当前数小数位的长度(处理科学计数法，本质上处理e-n的情况)\n  digitLength(num) {\n    const eSplit = num.toString().split(/[eE]/)\n    const len = (eSplit[0].split(\'.\')[1] || \'\').length - (+eSplit[1] || 0)\n    return len > 0 ? len : 0\n  }\n//  检测数字是否越界，如果越界给出提示\n  checkBoundary(num) {\n    if (num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER) {\n      console.log(`${num} is beyond boundary when transfer to integer, the results may not be accurate`)\n    }\n  }\n}\n\nconst Utils = {\n  precision: new Precision(),\n  // 获取小数位数\n  retainDecimals(value, obj = {}) {\n    if (!value) return 0\n    value = value.toString()\n    if (~value.indexOf(\'e\')) {\n      return 0\n    }\n    let decimals = \'\'\n    if (value.indexOf(\'.\') > 0 && obj.decimal !== 0) {\n      let decimalsRe = new RegExp(\'[.]{1}[0-9]{0,\' + (obj.decimal || 8) + \'}\')\n      let decimalsExec = decimalsRe.exec(value)\n      decimalsExec && (decimals = decimalsExec[0])\n    }\n    let v = 0\n    let re = new RegExp(\'^-?[0-9]{1}[0-9]{0,\' + (obj.integer - 1 || 8) + \'}\')\n    v = re.exec(value)\n    let n = \'\'\n    if (v) {\n      n = v[0]\n    }\n    return n + decimals\n  },\n\n  // 获取小数位数\n  retainDecimalsWithSymbol(value, obj = {}) {\n    if (!value) return 0\n    value = value.toString()\n    if (~value.indexOf(\'e\')) {\n      return 0\n    }\n    let decimals = \'\'\n    if (value.indexOf(\'.\') > 0 && obj.decimal !== 0) {\n      let decimalsRe = new RegExp(\'[.]{1}[0-9]{0,\' + (obj.decimal || 8) + \'}\')\n      let decimalsExec = decimalsRe.exec(value)\n      decimalsExec && (decimals = decimalsExec[0])\n    }\n    let v = 0\n    let re = new RegExp(\'^-?[0-9]{1}[0-9]{0,\' + (obj.integer - 1 || 8) + \'}\')\n    v = re.exec(value)\n    let n = \'\'\n    if (v) {\n      n = v[0]\n    }\n    let result = n + decimals\n    if (Number(result) < 0) {\n      return n + decimals\n    } else {\n      return \'+\' + n + decimals\n    }\n  },\n  // 数字加逗号\n  numberFormat(num) {\n    if (num) {\n      let [num1, num2] = num.toString().split(\'.\')\n      num1 = num1.split(\'\').reverse().map((item, index) => {\n        return (index) % 3 || !index || item === \'-\' || item === \'+\' ? item : item + \',\'\n      }).reverse().join(\'\')\n      num2 ? num = num1 + \'.\' + num2 : num = num1\n    }\n    return num\n  },\n  // 补充0\n  splitFormat(num, fractionDigits, len) {\n    if (isNaN(num)) return num\n    if (num) {\n      if (num === \'0\') {\n        return num\n      }\n      let digit = num.toString().split(\'.\')\n      if (fractionDigits === 0) {\n        return digit[0]\n      }\n      if (digit.length > 1) {\n        if (fractionDigits === 0) {\n          return digit[0]\n        } else if (digit[1].length < fractionDigits) {\n          let digitResult = \'\'\n          for (let i = 0; i < fractionDigits - digit[1].length; i++) {\n            digitResult += \'0\'\n          }\n          return num + digitResult\n        } else {\n          let digitResult = digit[1].substring(0, len || fractionDigits)\n          return digit[0] + \'.\' + digitResult\n        }\n      } else {\n        let digitResult = \'.\'\n        for (let i = 0; i < fractionDigits; i++) {\n          digitResult += \'0\'\n        }\n        return num + digitResult\n      }\n    } else {\n      return num\n    }\n  },\n  // 位数不够补0\n  addZero(num, len) {\n    if (isNaN(num)) return 0\n    let str = String(num)\n    // console.log(num, len)\n    return String(str).replace(new RegExp(`^(\\\\-?)(\\\\d+)(\\\\.\\\\d{1,${len}})?`), (n, a, b, c) => {\n      // console.log(a, b, c)\n      let str = a + b // .replace(/(\\d)(?=(?:\\d{3})+$)/g, \'$1,\')\n      if (!len) {\n        return str\n      }\n      if (c) {\n        str += c + repeat(\'0\', len - c.length)\n      } else {\n        str += \'.\' + repeat(\'0\', len)\n      }\n      return str\n    })\n  },\n  // 数字加逗号\n  addCommom(num, len) {\n    if (isNaN(num) || !num) return num\n    num = String(num)\n    if (!isNaN(len)) {\n      if (len === 0) {\n        num = num.split(\'.\')[0]\n      }\n      return num.replace(/(\\d+)(\\.\\d+)?/, (a, b, c) => {\n        // console.log(b, c)\n        return b.replace(/(\\d)(?=(?:\\d{3})+$)/g, \'$1,\') + (c ? c.slice(0, len + 1) : \'\')\n      })\n    } else {\n      return num.replace(/^\\d+/, (a) => { return a.replace(/(\\d)(?=(?:\\d{3})+$)/g, \'$1,\') })\n    }\n  },\n  // 获取时间年月日 时分秒\n  timeFormat(time, type) {\n    let date = getTimeZone(time)\n    if (!type) return getYMD(date) + \' \' + getHMS(date)\n    switch (type) {\n      case \'HMS\': return getHMS(date)\n      case \'YMD\': return getYMD(date)\n    }\n  },\n  cssProperty(attr) {\n    var prefix = [ \'O\', \'ms\', \'Moz\', \'Webkit\' ]\n    var len = prefix.length\n    var style = document.createElement(\'i\').style\n    if (attr in style) {\n      return true\n    }\n    attr = attr.replace(/^[a-z]/, function (val) {\n      return val.toUpperCase()\n    })\n    while (len--) {\n      if (prefix[ len ] + attr in style) {\n        return true\n      }\n    }\n    return false\n  },\n  /**\n * 防反跳。func函数在最后一次调用时刻的wait毫秒之后执行！\n * @param func 执行函数\n * @param wait 时间间隔\n * @param immediate 为true, debounce会在wait时间间隔的开始调用这个函数\n * @returns {Function}\n */\n  debounce(func, wait, immediate) {\n    var timeout, args, context, timestamp, result\n    var later = function () {\n      var last = new Date().getTime() - timestamp // timestamp会实时更新\n      if (last < wait && last >= 0) {\n        timeout = setTimeout(later, wait - last)\n      } else {\n        timeout = null\n        if (!immediate) {\n          result = func.apply(context, args)\n          if (!timeout) context = args = null\n        }\n      }\n    }\n    return function () {\n      context = this\n      args = arguments\n      timestamp = new Date().getTime()\n      var callNow = immediate && !timeout\n      if (!timeout) {\n        timeout = setTimeout(later, wait)\n      }\n      if (callNow) {\n        result = func.apply(context, args)\n        context = args = null\n      }\n      return result\n    }\n  }\n}\n  // 字符串复制\nfunction repeat(target, n) {\n  var s = \'\'\n  while (n > 0) {\n    if (n % 2 === 1) {\n      s += target\n    }\n    if (n === 1) { break }\n    target += target\n    n = n >> 1\n  }\n  return s\n}\nfunction singleFormat(str) {\n  return str.toString().length === 1 ? (\'0\' + str) : str\n}\n\nfunction getYMD(time) {\n  let year = time.getFullYear()\n  let month = time.getMonth() + 1\n  let date = time.getDate()\n  return year + \'-\' + singleFormat(month) + \'-\' + singleFormat(date)\n}\n\nfunction getHMS(time) {\n  let hours = time.getHours()\n  let minutes = time.getMinutes()\n  let seconds = time.getSeconds()\n  return singleFormat(hours) + \':\' + singleFormat(minutes) + \':\' + singleFormat(seconds)\n}\nfunction getTimeZone(time) {\n  let GTM_8 = 480  // -480\n  let date = new Date(time)\n  let subMin = date.getTimezoneOffset() + GTM_8\n  date.setMinutes(date.getMinutes() + subMin)\n  return date\n}\n\n/* harmony default export */ var util = (Utils);\n\n// CONCATENATED MODULE: ./src/js/formula/common.js\n  // IsReverse 是否是反向合约\n  function IsReverse(QuoteCoin, PriceCoin) {\n    return QuoteCoin === PriceCoin\n  }\n  // MarginCoin 保证金币\n  function MarginCoin(BaseCoin, QuoteCoin, PriceCoin) {\n    return IsReverse(QuoteCoin, PriceCoin) ? BaseCoin : QuoteCoin\n  }\n  \n\n// CONCATENATED MODULE: ./src/js/formula/value.js\n  \n  \n  // CalculateContractValue 通过量和价格计算合约价值\n  // vol:量\n  // price:价格\n  // contract:合约信息\n  function CalculateContractValue(vol, price, Contract) {\n    return calculateContractValue(vol, price, Contract.contractSize, IsReverse(Contract.quoteCoin, Contract.priceCoin))\n  }\n  function calculateContractValue(vol, price, contractSize, isReverse) {\n    let amount = 0\n    if (vol <= 0 || price === 0 || contractSize <= 0) {\n      return 0\n    }\n    if (isReverse) {\n      amount = util.precision.divide(util.precision.times(vol, contractSize), price)\n    } else {\n      amount = util.precision.times(vol, contractSize, price)\n    }\n    return amount\n  }\n  // CalculateQuotePrice 通过价值和量计算价格\n  // value:价值\n  // vol:量\n  // contract:合约\n  function CalculateQuotePrice(value, vol, contract) {\n    if (!contract) {\n      return 0\n    }\n    return calculateQuotePrice(value, vol, contract.contractSize, IsReverse(contract.quoteCoin, contract.priceCoin))\n  }\n  function calculateQuotePrice(value, vol, contractSize, isReverse) {\n    let price\n    if (contractSize <= 0) {\n      return 0\n    }\n    if (isReverse) {\n      if (value <= 0) {\n        return 0\n      }\n      price = vol * contractSize / value\n      return price\n    }\n    if (vol <= 0) {\n      return 0\n    }\n    price = value / vol / contractSize\n    return price\n  }\n  // CalculateContractBasicValue 通过量和价格计算合约的基础比价值\n  // coinUnit true  返回值单位为张  false 单位和BaseCoin单位一致\n  function CalculateContractBasicValue(vol, price, contract, coinUnit) {\n    // console.log(66)\n    let amount = 0\n    if (vol <= 0 || price <= 0 || !contract) {\n      return amount\n    }\n    amount = vol\n    if (IsReverse(contract.quoteCoin, contract.priceCoin)) {\n      amount = coinUnit ? Math.floor(amount * price / contract.contractSize) : amount / price * contract.contractSize\n      return amount\n    }\n    return coinUnit ? Math.floor(amount / contract.contractSize) : util.precision.times(amount, contract.contractSize)\n  }\n\n    // CalculateContractBasicValue 通过量和价格计算合约的基础比价值\n  // 把张换成mrginCoin\n  function CalculateContractBasicValueTwo(vol, price, contract) {\n    let amount = 0\n    if (vol <= 0 || price <= 0 || !contract) {\n      return amount\n    }\n    amount = vol\n    if (IsReverse(contract.quoteCoin, contract.priceCoin)) {\n      return amount / price * contract.contractSize\n    }\n    return amount * contract.contractSize * price\n  }\n\n  \n\n// CONCATENATED MODULE: ./src/js/formula/margin.js\n  \n  // CalculateMMR 计算维持保证金率\n  function CalculateMMR(value, riskLimit) {\n    if (value <= riskLimit.BaseLimit || riskLimit.Step <= 0) {\n      return riskLimit.MaintenanceMargin\n    }\n    let stepValue = value - riskLimit.BaseLimit\n    let stepsCount = Math.ceil(stepValue / riskLimit.Step)\n    let MMR = riskLimit.MaintenanceMargin * (stepsCount + 1)\n    // 大于0.5\n    if (MMR > 0.5) {\n      return 0.5\n    }\n    return MMR\n  }\n  // CalculateMM 计算维持保证金\n  function CalculateMM(value, riskLimit) {\n    let MMR\n    if (value <= 0) {\n      return 0\n    }\n    MMR = CalculateMMR(value, riskLimit)\n    return value * MMR\n  }\n  // CalculateIMR 计算开仓保证金率\n  function CalculateIMR(value, riskLimit) {\n    if (value < riskLimit.BaseLimit || riskLimit.Step <= 0) {\n      return riskLimit.InitialMargin\n    }\n    let IMR = (Math.ceil((value - riskLimit.BaseLimit) / riskLimit.Step) + 1) * riskLimit.InitialMargin\n    return IMR > 1 ? 1 : IMR\n  }\n  // CalculateMarketOrderIMR 通过用户资产计算用户将资产全部开市价单时的开仓保证金率\n  // asset:用户资产\n  // advance:用户的已提交委托订单价值\n  // position:用户仓位\n  // contractInfo:合约信息\n  function CalculateMarketOrderIMR(asset, advance, position, contractInfo, way) {\n    let advanceValue = 0\n    let holdValue = 0\n    let preValue = 0\n    let IMR, IMR2\n    let takeFeeRatio = contractInfo.FeeConfig.TakerFee\n    if (advance && advance.Vol) {\n      advanceValue = CalculateContractValue(advance.Vol, advance.Amount / advance.Vol, contractInfo.Contract)\n    }\n    if (position) {\n      holdValue = CalculateContractValue(position.HoldVol, position.HoldAvgPrice, contractInfo.Contract)\n    }\n    preValue = advanceValue + holdValue\n    let i = 0\n    while (++i) {\n      IMR = contractInfo.RiskLimit.InitialMargin * i\n      IMR2 = CalculateIMR(asset / (IMR + 2 * takeFeeRatio + (way ? 0 : takeFeeRatio * IMR)) + preValue, contractInfo.RiskLimit)\n      if (IMR >= IMR2) {\n        return IMR\n      }\n    }\n  }\n  \n\n// CONCATENATED MODULE: ./src/js/formula/open.js\n  \n  \n  // CalculateAdvanceOpenCost 提交开仓订单时,计算预开仓成本\n  // order:订单信息\n  // position:用户持有仓位\n  // openOrderSize:已提交的委托订单大小\n  // contractInfo:合约信息\n  // way 是否开多 traue : false\n  function CalculateAdvanceOpenCost(order, position, openOrderSize, Contract, RiskLimit, way) {\n    if (order.Vol <= 0 || order.Price <= 0) {\n      return 0\n    }\n    let holdVol = 0\n    let holdAvgPrice = 0\n    let advanceVol = 0\n    let advancePrice = 0\n    if (position) {\n      holdVol = position.HoldVol\n      holdAvgPrice = position.HoldAvgPrice\n    }\n    if (openOrderSize && openOrderSize.Vol > 0) {\n      advanceVol = openOrderSize.Vol\n      advancePrice = openOrderSize.Amount / openOrderSize.Vol\n    }\n    return _calculateAdvanceOpenCost(holdVol, advanceVol, holdAvgPrice, advancePrice, order, Contract, RiskLimit, way)\n  }\n  function _calculateAdvanceOpenCost(holdVol, advanceVol, holdAvgPrice, advancePrice, order, Contract, RiskLimit, way) {\n    let orderValue = CalculateContractValue(order.Vol, order.Price, Contract)\n    let advanceValue = CalculateContractValue(advanceVol, advancePrice, Contract)\n    let holdValue = CalculateContractValue(holdVol, holdAvgPrice, Contract)\n    let totalValue = orderValue + advanceValue + holdValue\n    // 开仓保证金率\n    order.IMR = CalculateIMR(totalValue, RiskLimit)\n    if (order.Leverage > 0) {\n      let leverageIMR = 1 / order.Leverage\n      if (leverageIMR > order.IMR) {\n        order.IMR = leverageIMR\n      }\n    }\n    let IM = orderValue * order.IMR\n    let brankruptTakeFee = orderValue * BTR(way, order.TakeFeeRatio, order.IMR)\n    let MaxTakeFee = orderValue * order.TakeFeeRatio + brankruptTakeFee\n    let FreezAssets = IM + MaxTakeFee\n    return FreezAssets\n  }\n  // 是否开多单\n  // BTR 获取订单破产时的takeFeeRatio\n  function BTR(way, TakeFeeRatio, IMR) {\n    return way ? TakeFeeRatio : (TakeFeeRatio * (1 + IMR))\n  }\n  /* harmony default export */ var formula_open = (CalculateAdvanceOpenCost);\n\n// CONCATENATED MODULE: ./src/js/formula/volume.js\n\n\n\n// -----------------------------------------------------------计算市价可开多少张 ------------------\n// CalculateVolume 通过资产和价格,计算量\n// asset:资产\n// advance:用户的已提交委托订单价值\n// position:用户仓位\n// price:价格\n// way:开仓类型,是开多,还是开空\n// contractInfo:合约信息\n// leverage 杠杆\nfunction CalculateVolume(asset, advance, position, price, contractInfo, way, leverage) {\n  if (asset <= 0) {\n    return 0\n  }\n  let IMR, takeFeeRatio, bankruptTakeFeeRatio, M, IMRT\n  IMRT = CalculateMarketOrderIMR(asset, advance, position, contractInfo, way)\n  IMR = Math.max(IMRT, 1 / leverage)\n\n  takeFeeRatio = contractInfo.FeeConfig.TakerFee\n  bankruptTakeFeeRatio = takeFeeRatio\n  if (!way) { // 开空\n    bankruptTakeFeeRatio = takeFeeRatio * (1 + IMR)\n  }\n  // 空仓 bankruptTakeFeeRatio = BTR =  (1+IMR)*TR\n  // 多仓 bankruptTakeFeeRatio = TR\n  // A = vol * p * s * [IMR + TR + BTR]\n  let isR = IsReverse(contractInfo.Contract.quoteCoin, contractInfo.Contract.priceCoin) // asset = vol * price*s*(IMR+2*takeFeeRatio)\n      // asset = vol*s*(IMR+2*takeFeeRatio)/price\n    // D = asset * price\n    // M = s*(IMR+2*takeFeeRatio)\n  M = contractInfo.Contract.contractSize * (IMR + takeFeeRatio + bankruptTakeFeeRatio)\n  if (M <= 0) {\n    return 0\n  }\n  price = isR ? price : 1 / price\n  let max = Math.floor(asset * price / M)\n  if (IMR > contractInfo.RiskLimit.InitialMargin) {\n    let advanceValue = 0\n    let holdValue = 0\n    if (advance && advance.Vol) {\n      advanceValue = CalculateContractValue(advance.Vol, advance.Amount / advance.Vol, contractInfo.Contract)\n    }\n    if (position) {\n      holdValue = CalculateContractValue(position.HoldVol, position.HoldAvgPrice, contractInfo.Contract)\n    }\n    let up = Math.floor(price * ((IMRT / contractInfo.RiskLimit.InitialMargin - 2) * contractInfo.RiskLimit.Step + contractInfo.RiskLimit.BaseLimit - advanceValue - holdValue) / contractInfo.Contract.contractSize)\n    max = IMRT <= 1 / leverage ? max : Math.max(max, up)\n  }\n  return max\n}\n\n\n// CONCATENATED MODULE: ./src/js/formula/close.js\n\n// CalculateCloseLongProfitAmount 计算多仓位的未实现盈亏\n// vol:持仓量\n// openPrice:持仓均价\n// closePrice:当前标记价\n// contractSize:合约大小\n// isReverse:是否是反向合约\nfunction CalculateCloseLongProfitAmount(vol, openPrice, closePrice, contract) {\n  if (vol <= 0 || contract.contractSize <= 0 || openPrice <= 0 || closePrice <= 0) {\n    return 0\n  }\n  // let openValue, closeValue\n  if (IsReverse(contract.quoteCoin, contract.priceCoin)) {\n    // openValue = vol * contract.contractSize / openPrice\n    // closeValue = vol * contract.contractSize / closePrice\n    return vol * contract.contractSize * (1 / openPrice - 1 / closePrice) // openValue - closeValue\n  }\n  // openValue = vol * contract.contractSize * openPrice\n  // closeValue = vol * contract.contractSize * closePrice\n  return vol * contract.contractSize * (closePrice - openPrice) // closeValue - openValue\n}\n// CalculateCloseShortProfitAmount 计算空仓位的未实现盈亏\n// vol:持仓量\n// openPrice:持仓均价\n// closePrice:当前标记价\n// contractSize:合约大小\n// isReverse:是否是是方向合约\n// let openValue, closeValue\nfunction CalculateCloseShortProfitAmount(vol, openPrice, closePrice, contract) {\n  if (vol <= 0 || contract.contractSize <= 0 || openPrice <= 0 || closePrice <= 0) {\n    return 0\n  }\n  if (IsReverse(contract.quoteCoin, contract.priceCoin)) {\n    // openValue = vol * contract.contractSize / openPrice\n    // closeValue = vol * contract.contractSize / closePrice\n    return vol * contract.contractSize * (1 / closePrice - 1 / openPrice) // closeValue - openValue\n  }\n  // openValue = vol * contract.contractSize * openPrice\n  // closeValue = vol * contract.contractSize * closePrice\n  return vol * contract.contractSize * (openPrice - closePrice) // openValue - closeValue\n}\nfunction LongOrSort(vol, openPrice, closePrice, contract, way) {\n  return way ? CalculateCloseLongProfitAmount(vol, openPrice, closePrice, contract) : CalculateCloseShortProfitAmount(vol, openPrice, closePrice, contract)\n}\n/* harmony default export */ var formula_close = (LongOrSort);\n\n// CONCATENATED MODULE: ./src/js/formula/contractObj.js\n/* harmony default export */ var contractObj = ({\n  // 获取合约信息\n  getContract(productInfo) {\n    return {contractSize: Number(productInfo.face_value), quoteCoin: productInfo.quote_coin, priceCoin: productInfo.is_reverse ? productInfo.quote_coin : productInfo.base_coin}\n  },\n  // 获取合约系数\n  getRiskLimit(risk_limit) {\n    return {BaseLimit: Number(risk_limit.risk_limit_base), Step: Number(risk_limit.risk_limit_step), InitialMargin: Number(risk_limit.imr), MaintenanceMargin: Number(risk_limit.mmr)}\n  }\n});\n\n// CONCATENATED MODULE: ./src/js/formula/bankrupt.js\n// 破产相关公式\n\n\n// CalculateBankruptcyPrice 计算破产价\n// position:用户的仓位\n// assets:用户的资产,如果仓位的全仓模式,需要传入用户资产,如果是逐仓模式,不需要传入用户资产\nfunction CalculateBankruptcyPrice(position, assets, contractInfo, way) {\n  let HV, HP, PV, IM, resValue, S, T, M, D, BP\n  HV = position.HoldVol\n  HP = position.HoldAvgPrice\n  PV = CalculateContractValue(HV, HP, contractInfo.Contract)\n  // 当前仓位需要的维持保证金\n  IM = position.IM\n  if (assets) {\n    IM = IM + assets\n  }\n  // ToDo 保证金不够怎么办\n  // if (IM < 0) {\n  //   return -1\n  // }\n  S = contractInfo.Contract.contractSize\n  T = contractInfo.FeeConfig.TakerFee\n  // HV: hold volume\n  // BP: 破产价\n  // S: 合约价格\n  // T: TakeFeeRatio\n  // TF: TakeFee\n  // HV*BP*S*T = TF\n  // 多仓\n  // PV-IM = resValue\n  // (resValue-TF)/(HV*S) = BP\n  // resValue/(HV*S+HV*S*T) = BP\n  // 空仓\n  // PV+IM = resValue\n  // (PV+IM-TF)/(HV*S) = BP\n  // resValue/(HV*S+HV*S*T) = BP\n  // 破产时用户持仓的价值\n  // 开多仓,破产时的仓位价值 = 现在的仓位价值 - 开仓保证金\n  // 开空仓,破产时的仓位价值 = 现在的仓位价值 + 开仓保证金\n  let isR = IsReverse(contractInfo.Contract.quoteCoin, contractInfo.Contract.priceCoin)\n  if (isR) {\n    way = !way\n  }\n  if (way) {\n    resValue = PV - IM\n    // 如果保证金大于仓位的资产,肯定没有达到强平位置\n    if (resValue <= 0) {\n      return 0\n    }\n    D = HV * S * (1 - T)\n  } else {\n    resValue = PV + IM\n    D = HV * S * (1 + T)\n  }\n  M = resValue\n  if (D <= 0) {\n    return -1\n  }\n  BP = M / D\n  if (isR) {\n    if (BP <= 0) {\n      return -1\n    }\n    BP = 1 / BP\n  }\n  return BP\n}\n/* harmony default export */ var bankrupt = (CalculateBankruptcyPrice);\n\n// CONCATENATED MODULE: ./src/js/formula/adl.js\n\n\n\n// CalculatePnl 计算仓位盈利排名系数\n// 排序 = 盈利百分比 * 有效杠杆  (如果盈利)\n//         = 盈利百分比 / 有效杠杆  (如果亏损)\n// 其中\n//   有效杠杆 = abs((标记价值) / (标记价值 - 破产价值))\n//   盈利百分比 = (标记价值 - 平均开仓价值) / abs(平均开仓价值)\n//   标记价值 = 位于标记价格时的仓位价值\n//   破产价值 = 位于破产价格时的仓位价值\n//   平均开仓价值 = 位于平均开仓价格时的仓位价值\n\nfunction CalculatePNL(position, assets, fairPrice, contractInfo, way) {\n  // 盈利百分比 = (标记价值 - 平均开仓价值) / abs(平均开仓价值)\n  // 盈利百分比= [FP*Vol*S - HP*Vol*S]/HP*Vol*S\n  // 有效杠杆 = abs[(标记价值) / (标记价值 - 破产价值)]\n  // 有效杠杠 = abs[FP*Vol*S/(FP*Vol*S - BP*Vol*S)]\n  // 排序 = [(FP*Vol*S - HP*Vol*S)/HP*Vol*S]*abs[FP*Vol*S/(FP*Vol*S - BP*Vol*S)]\n  // Pnl = [(FP - HP)/HP]*abs[FP/(FP - BP)]\n  if (!position) {\n    return 0\n  }\n  let profit, positionValue, earningsRatio, BP, tmp, leverage\n  profit = formula_close(position.HoldVol, position.HoldAvgPrice, fairPrice, contractInfo.Contract, way)\n  positionValue = CalculateContractValue(position.HoldVol, position.HoldAvgPrice, contractInfo.Contract)\n  earningsRatio = profit / positionValue\n  BP = bankrupt(position, assets, contractInfo)\n  tmp = fairPrice - BP\n  if (tmp === 0) {\n    if (profit > 0) {\n      return 100000000\n    } else {\n      return 0\n    }\n  }\n  leverage = Math.abs(fairPrice / tmp)\n  if (leverage === 0) {\n    if (profit > 0) {\n      return 0\n    }\n    return -100000000\n  }\n  if (profit < 0) {\n    return earningsRatio / leverage\n  }\n  return earningsRatio * leverage\n}\n\nfunction CalculateQuantile(i, size) {\n  let f = Math.ceil(i * 5 / size)\n  f *= 0.2\n  return f * 100\n}\n\n\n\n// CONCATENATED MODULE: ./src/js/formula/liquidate.js\n  // -------------------------- 开仓验证 --------------------------------------\n  // 1.在最大和最小区间内\n  // 2.必须小于等于最大可开\n  // 3.判断价格是不是强平价\n  // IsLiquidate 根据价格和开仓方向判断是否会强平\n  // positionType:开仓方向\n  // positionLiquidatePrice:强平价\n  // fairPrice:当前合理价格\n  \n  \n  \n  function IsLiquidate(longOrSort, positionLiquidatePrice, fairPrice) {\n    if (positionLiquidatePrice < 0) {\n      return true\n    } else if (positionLiquidatePrice === 0) {\n      return false\n    }\n    if (longOrSort) {\n      if (fairPrice <= positionLiquidatePrice) {\n        return true\n      }\n    } else {\n      if (fairPrice >= positionLiquidatePrice) {\n        return true\n      }\n    }\n    return false\n  }\n  // CalculateOrderLiquidatePrice 计算订单的强平价\n  // order:订单\n  // assets:用户资产,如果是全仓模式,才需要输入用户资产,逐仓模式不需要\n  // contractInfo:合约信息\n  function CalculateOrderLiquidatePrice(order, asset, contractInfo, longOrSort) {\n    let value, restM, MM, IMR, leverageIMR, IM\n    value = CalculateContractValue(order.Vol, order.Price, contractInfo.Contract)\n    restM = 0\n    MM = CalculateMM(value, contractInfo.RiskLimit)\n    // 如果是全仓模式\n    // 全仓模式,不考虑用户输入的杠杆大小\n    if (order.OpenType) {\n      if (asset) {\n        restM = asset - MM // asset.AvailableVol\n      }\n    } else {\n      // 如果是逐仓模式\n      IMR = CalculateIMR(value, contractInfo.RiskLimit)\n      if (order.Leverage > 0) {\n        leverageIMR = 1 / order.Leverage\n        if (leverageIMR > IMR) {\n          IMR = leverageIMR\n        }\n      }\n      IM = value * IMR\n      restM = IM - MM\n    }\n    if (restM < 0) {\n      // 如果返回小于零,表示订单无效\n      return -1\n    }\n    let isR = IsReverse(contractInfo.Contract.quoteCoin, contractInfo.Contract.priceCoin)\n    if (isR) {\n      longOrSort = !longOrSort\n    }\n    // 如果开多\n    if (longOrSort) {\n      value = value - restM\n      // 用户资产的价值大于订单的价值\n      // 只要当合约价格清零时才会强平\n      if (value <= 0) {\n        // 返回零\n        return isR ? 100000000 : 0\n      }\n    } else {\n      value = value + restM\n    }\n    return CalculateQuotePrice(value, order.Vol, contractInfo.Contract)\n  }\n  // CalculatePositionLiquidatePrice 计算仓位的强平价\n  // position:仓位\n  // assets:用户资产,如果是全仓模式,才需要输入用户资产,逐仓模式不需要\n  // contractInfo:合约信息\n  function CalculatePositionLiquidatePrice(position, assets, contractInfo, longOrSort) {\n    let HV, HP, PV, resValue, IM, restM, T, D, M, LP\n    HV = position.HoldVol\n    HP = position.HoldAvgPrice\n    PV = CalculateContractValue(HV, HP, contractInfo.Contract)\n    // 当前仓位需要的维持保证金\n    IM = position.IM\n    if (assets) {\n      IM = IM + assets\n    }\n    restM = IM - position.MM\n    // ToDo 保证金不够怎么办\n    // if (restM < 0) {\n    //   return -1\n    // }\n    let S = contractInfo.Contract.contractSize\n    T = contractInfo.FeeConfig.TakerFee\n    // HV: hold volume\n    // LP: 强平价\n    // S: 合约价格\n    // T: TakeFeeRatio\n    // TF: TakeFee\n    // HV*LP*S*T = TF\n    // 多仓\n    // PV-(IM-MM) = resValue\n    // (resValue+TF)/(HV*S) = LP\n    // resValue/(HV*S-HV*S*T) = LP\n    // 空仓\n    // PV+(IM-MM) = resValue\n    // (PV+(IM-MM)-TF)/(HV*S) = LP\n    // resValue/(HV*S+HV*S*T) = LP\n    D = 0\n    let isR = IsReverse(contractInfo.Contract.quoteCoin, contractInfo.Contract.priceCoin)\n    if (isR) {\n      longOrSort = !longOrSort\n    }\n    // 判断是否是开多\n    if (longOrSort) {\n      resValue = PV - restM\n      // 如果保证金大于仓位的资产,肯定没有达到强平位置\n      if (resValue <= 0) {\n        return isR ? 100000000 : 0\n      }\n      D = HV * S * (1 - T)\n    } else {\n      resValue = PV + restM\n      D = HV * S * (1 + T)\n    }\n    M = resValue\n    if (D <= 0) {\n      return -1\n    }\n    LP = M / D\n    if (isR) {\n      LP = 1 / LP\n    }\n    if (LP > 100000000) {\n      LP = 100000000\n    }\n    return LP\n  }\n  \n\n// CONCATENATED MODULE: ./src/js/formula/index.js\n\n\n\n\n\n\n\n\n/* harmony default export */ var formula = ({ CalculateContractValue: CalculateContractValue, CalculateAdvanceOpenCost: formula_open, CalculateContractBasicValue: CalculateContractBasicValue, MarginCoin: MarginCoin, CalculateVolume: CalculateVolume, LongOrSort: formula_close, contractObj: contractObj, CalculatePNL: CalculatePNL, CalculateQuantile: CalculateQuantile, CalculateOrderLiquidatePrice: CalculateOrderLiquidatePrice, IsLiquidate: IsLiquidate, CalculatePositionLiquidatePrice: CalculatePositionLiquidatePrice, IsReverse: IsReverse, CalculateContractBasicValueTwo: CalculateContractBasicValueTwo, CalculateQuotePrice: CalculateQuotePrice });\n\n// CONCATENATED MODULE: ./src/index.js\n\r\n\r\n\r\n\r\n\r\nnew Vue({\r\n  el: \'#app\',\r\n  filters: {\r\n    addCommom: util.addCommom\r\n  },\r\n  data() {\r\n    return {\r\n      // 计算方案 1： 盈亏计算  2. 强平价格 3.目标价收益率\r\n      calculatorType: 1,\r\n      // 杠杆列表，数据需从数据库获取\r\n      leverageList: [\r\n        {"name": "allCabin", "value": 100},\r\n        {"name": "100x", "value": 100},\r\n        {"name": "50x", "value": 50},\r\n        {"name": "20x", "value": 20},\r\n        {"name": "10x", "value": 10}\r\n      ],\r\n      form: {\r\n        // 杠杆\r\n        leverageInfo: {\r\n          value: \'\'\r\n        },\r\n        // 计算类型，1：目标收益额，2：目标收益率\r\n        targetEarnings: 1,\r\n        calculatorType: 1, // 计算类型\r\n        options: 1, // 方向\r\n        positions: \'\', // 仓位\r\n        openPrice: \'\', // 开仓价格\r\n        closePrice: \'\', // 平仓价格\r\n        earnings: \'\', // 收益额或者收益率\r\n      },\r\n      // 盈亏计算\r\n      profitAndLoss: {\r\n        im: 0, // 占用保证金\r\n        value: 0, // 仓位价值\r\n        pl: 0, // 盈亏\r\n        rate: 0 // 收益率\r\n      },\r\n      // 强平价格\r\n      flatPrice: {\r\n        flatPrice: 0, // 强平价格\r\n        value: 0, // 仓位价值\r\n        im: 0, // 实际起始保证金率\r\n        mm: 0   // 实际维持保证金率\r\n      },\r\n      // 目标价收益率\r\n      targetClose: {\r\n        price: 0,\r\n        im: 0,\r\n        valueOrRote: 0\r\n      },\r\n      // 需从后台获取数据\r\n      productInfo: {\r\n        //"instrument_id": 1,\r\n        //"index_id": 1,\r\n        "symbol": "BTCUSDT",\r\n        //"name_zh": "BTCUSDT永续合约",\r\n        //"name_en": "BTCUSDT SWAP",\r\n        "base_coin": "BTC",\r\n        "quote_coin": "USDT",\r\n        //"margin_coin": "USDT",\r\n        "is_reverse": false,\r\n        "market_name": "*",\r\n        "face_value": "0.0001",\r\n        //"begin_at": "2019-10-29T00:00:00Z",\r\n        //"settle_at": "2020-03-01T16:00:00Z",\r\n        //"settlement_interval": 28800,\r\n        //"min_leverage": "1",\r\n        //"max_leverage": "100",\r\n        //"px_unit": "0.01",\r\n        //"qty_unit": "1",\r\n        //"value_unit": "0.0001",\r\n        //"min_qty": "1",\r\n        //"max_qty": "100000000",\r\n        //"position_type": 3,\r\n        //"underweight_type": 1,\r\n        //"status": 3,\r\n        //"area": 1,\r\n        //"created_at": "2019-11-19T10:41:38.059456Z",\r\n        //"depth_round": "1.01",\r\n        //"max_funding_rate": "0.00375",\r\n        //"min_funding_rate": "-0.00375",\r\n        "risk_limit_base": "1000000",\r\n        "risk_limit_step": "500000",\r\n        "mmr": "0.005",\r\n        "imr": "0.01",\r\n        //"maker_fee_ratio": "0.00025",\r\n        //"taker_fee_ratio": "0.00075",\r\n        //"settle_fee_ratio": "0",\r\n        //"plan_order_price_min_scope": "0.001",\r\n        //"plan_order_price_max_scope": "2",\r\n        //"plan_order_max_count": 10,\r\n        //"plan_order_min_life_cycle": 24,\r\n        //"plan_order_max_life_cycle": 168,\r\n        "price_coin": "BTC"\r\n      }\r\n    };\r\n  },\r\n  computed: {\r\n    // 公共数据，需从后台获取\r\n    common() {\r\n      let obj = {\r\n        "pxUnit": 2,\r\n        //"qtyUnit": 1,\r\n        "valueUnit": 4,\r\n        "marginUnit": "USDT",\r\n        //"haveAssert": 0,\r\n        //"positionLoss": 0,\r\n        //"showOpenAccount": false,\r\n        "PNL": 0,\r\n        //"liquidateAssertLong": 0,\r\n        //"liquidateAssertSort": 0,\r\n        //"imTotal": 0,\r\n        /*"leverageList": [\r\n          {"name": "allCabin", "value": 100},\r\n          {"name": "100x", "value": 100},\r\n          {"name": "50x","value": 50},\r\n          {"name": "20x", "value": 20},\r\n          {"name": "10x", "value": 10}\r\n        ],*/\r\n        //"isPlan": false,\r\n        //"limitType": 1\r\n      };\r\n      return obj;\r\n    },\r\n  },\r\n  methods: {\r\n    calculator() {\r\n      let form = this.form;\r\n      let profitAndLoss = this.profitAndLoss;\r\n      switch (this.calculatorType) {\r\n        case 1:\r\n          if (!form.positions || !form.openPrice || !form.closePrice) {\r\n            this.$notify.warning({\r\n              title: \'提示\',\r\n              message: \'缺少必要参数，请补充完整参数\'\r\n            });\r\n            return false;\r\n          }\r\n          // 仓位价值\r\n          this.profitAndLoss.value = this.CalculateContractValue(Number(form.positions), Number(form.openPrice));\r\n          let margin = this.marginRate(this.profitAndLoss.value);\r\n          // 占用保证金\r\n          this.profitAndLoss.im = profitAndLoss.value * Math.max(margin.initial, 1 / form.leverageInfo.value);\r\n          // 盈亏\r\n          this.profitAndLoss.pl = this.plFn(form.openPrice, form.closePrice, Number(form.positions), form.options === 1);\r\n          // 收益率\r\n          this.profitAndLoss.rate = profitAndLoss.pl / profitAndLoss.im * 100;\r\n          break;\r\n        case 2:\r\n          if (!form.positions || !form.openPrice) {\r\n            this.$notify.warning({\r\n              title: \'提示\',\r\n              message: \'缺少必要参数，请补充完整参数\'\r\n            });\r\n            return false;\r\n          }\r\n          this.flatPrice.value = this.CalculateContractValue(Number(form.positions), Number(form.openPrice));\r\n          let margin1 = this.marginRate(this.flatPrice.value);\r\n          this.flatPrice.im = Math.max(margin1.initial, 1 / form.leverageInfo.value);\r\n          this.flatPrice.mm = margin1.maintenance;\r\n          // let fee = Number(this.productInfo.taker_fee_ratio)\r\n          // let position = {HoldVol: Number(this.positions), HoldAvgPrice: Number(this.openPrice), IM: this.flatPrice.im, MM: this.flatPrice.mm}\r\n          // this.flatPrice.flatPrice = Formula.CalculatePositionLiquidatePrice(position, 0, this.getContractInfo(), !this.options)\r\n          // let pl = this.flatPrice.value * (margin.initial - margin.maintenance) * (this.options ? 1 + fee : 1 - fee)\r\n          this.flatPrice.flatPrice = this.liquidatePrice(Number(form.positions), Number(form.openPrice), form.leverageInfo.value);\r\n          break;\r\n        case 3:\r\n          if (!form.positions || !form.openPrice || !form.earnings) {\r\n            this.$notify.warning({\r\n              title: \'提示\',\r\n              message: \'缺少必要参数，请补充完整参数\'\r\n            });\r\n            return false;\r\n          }\r\n          let value = this.CalculateContractValue(Number(form.positions), Number(form.openPrice));\r\n          let margin2 = this.marginRate(value);\r\n          this.targetClose.im = value * Math.max(margin2.initial, 1 / form.leverageInfo.value);\r\n          let isR = formula.IsReverse(this.productInfo.quote_coin, this.productInfo.price_coin);\r\n          let optionsTrue = form.options === 1;\r\n          if (form.targetEarnings === 1) {\r\n            if ((optionsTrue && !isR) || (!optionsTrue && isR)) {\r\n              value += Number(form.earnings);\r\n            } else {\r\n              value -= Number(form.earnings);\r\n            }\r\n            this.targetClose.valueOrRote = form.earnings / this.targetClose.im;\r\n          } else {\r\n            this.targetClose.valueOrRote = form.earnings * this.targetClose.im / 100;\r\n            if ((optionsTrue && !isR) || (!optionsTrue && isR)) {\r\n              value += this.targetClose.valueOrRote;\r\n            } else {\r\n              value -= this.targetClose.valueOrRote;\r\n            }\r\n          }\r\n          this.targetClose.price = this.targetClosePriceFn(value, Number(form.positions));\r\n          break;\r\n      }\r\n    },\r\n    // 获取合约对象\r\n    getContractInfo() {\r\n      let  productInfo = this.productInfo;\r\n      return {\r\n        FeeConfig: {TakerFee: Number(productInfo.taker_fee_ratio)},\r\n        Contract: formula.contractObj.getContract(productInfo),\r\n        RiskLimit: formula.contractObj.getRiskLimit(productInfo)\r\n      };\r\n    },\r\n    // 算仓位价值\r\n    CalculateContractValue(vol, price) {\r\n      return formula.CalculateContractValue(vol, price, formula.contractObj.getContract(this.productInfo))\r\n    },\r\n    // 盈亏计算\r\n    plFn(open, close, positions, way) {\r\n      return formula.LongOrSort(positions, open, close, formula.contractObj.getContract(this.productInfo), way) || 0\r\n    },\r\n    // 计算目标平仓价格\r\n    targetClosePriceFn(value, vol) {\r\n      return formula.CalculateQuotePrice(value, vol, formula.contractObj.getContract(this.productInfo))\r\n    },\r\n    // 计算目标平仓价格\r\n    liquidatePrice(Vol, Price, Leverage) {\r\n      let optionsTrue = this.form.options === 1;\r\n      return formula.CalculateOrderLiquidatePrice({Vol, Price, Leverage}, 0, this.getContractInfo(), optionsTrue);\r\n    },\r\n    // 计算起始和维持保证金率\r\n    marginRate(totalValue) {\r\n      let risk = this.productInfo;\r\n      let initial = Number(risk.imr);\r\n      let maintenance = Number(risk.mmr);\r\n      if (totalValue > risk.risk_limit_base) {\r\n        let steps = Math.ceil((totalValue - risk.risk_limit_base) / risk.risk_limit_step);\r\n        initial = util.precision.times(steps + 1, initial);\r\n        maintenance = util.precision.times(steps + 1, maintenance);\r\n      }\r\n      if (initial > 1) {\r\n        initial = 1;\r\n      }\r\n      if (maintenance > 0.5) {\r\n        maintenance = 0.5;\r\n      }\r\n      return {initial, maintenance};\r\n    },\r\n  }\r\n});\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy91dGlsLmpzP2Y2NDQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2Zvcm11bGEvY29tbW9uLmpzPzc5ZTEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2Zvcm11bGEvdmFsdWUuanM/MTlhZiIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZm9ybXVsYS9tYXJnaW4uanM/NTI2YiIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZm9ybXVsYS9vcGVuLmpzPzhiNzYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2Zvcm11bGEvdm9sdW1lLmpzP2Y3MDkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2Zvcm11bGEvY2xvc2UuanM/YWZkMSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZm9ybXVsYS9jb250cmFjdE9iai5qcz8wZjIxIiwid2VicGFjazovLy8uL3NyYy9qcy9mb3JtdWxhL2JhbmtydXB0LmpzPzkyNTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2Zvcm11bGEvYWRsLmpzPzQyMzIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2Zvcm11bGEvbGlxdWlkYXRlLmpzPzIyZjEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2Zvcm11bGEvaW5kZXguanM/ZWE2OCIsIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXguanM/YjYzNSJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBQcmVjaXNpb24ge1xuICAvLyDkuZjms5VcbiAgdGltZXMobnVtMSwgbnVtMiwgLi4ub3RoZXJzKSB7XG4gICAgaWYgKG90aGVycy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gdGhpcy50aW1lcyh0aGlzLnRpbWVzKG51bTEsIG51bTIpLCAuLi5vdGhlcnMpXG4gICAgfVxuICAgIG51bTEgPSBudW0xIHx8IDBcbiAgICBudW0yID0gbnVtMiB8fCAwXG4gICAgY29uc3QgbnVtMUNoYW5nZWQgPSB0aGlzLmZsb2F0MkZpeGVkKG51bTEpXG4gICAgY29uc3QgbnVtMkNoYW5nZWQgPSB0aGlzLmZsb2F0MkZpeGVkKG51bTIpXG4gICAgLy8g5oqK5Lik5Liq5pWw55qE5bCP5pWw5L2N5pWw55u45YqgXG4gICAgY29uc3QgYmFzZU51bSA9IHRoaXMuZGlnaXRMZW5ndGgobnVtMSkgKyB0aGlzLmRpZ2l0TGVuZ3RoKG51bTIpXG4gICAgY29uc3QgbGVmdFZhbHVlID0gbnVtMUNoYW5nZWQgKiBudW0yQ2hhbmdlZFxuICAgIC8vIHRoaXMuY2hlY2tCb3VuZGFyeShsZWZ0VmFsdWUpXG4gICAgcmV0dXJuIGxlZnRWYWx1ZSAvIE1hdGgucG93KDEwLCBiYXNlTnVtKVxuICB9XG4vLyDnsr7noa7liqDms5VcbiAgcGx1cyhudW0xLCBudW0yLCAuLi5vdGhlcnMpIHtcbiAgICBpZiAob3RoZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnBsdXModGhpcy5wbHVzKG51bTEsIG51bTIpLCAuLi5vdGhlcnMpXG4gICAgfVxuICAgIGNvbnN0IGJhc2VOdW0gPSBNYXRoLnBvdygxMCwgTWF0aC5tYXgodGhpcy5kaWdpdExlbmd0aChudW0xKSwgdGhpcy5kaWdpdExlbmd0aChudW0yKSkpXG4gICAgcmV0dXJuICh0aGlzLnRpbWVzKG51bTEsIGJhc2VOdW0pICsgdGhpcy50aW1lcyhudW0yLCBiYXNlTnVtKSkgLyBiYXNlTnVtXG4gIH1cbi8vIOeyvuehruWHj+azlVxuICBtaW51cyhudW0xLCBudW0yLCAuLi5vdGhlcnMpIHtcbiAgICBpZiAob3RoZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLm1pbnVzKHRoaXMubWludXMobnVtMSwgbnVtMiksIC4uLm90aGVycylcbiAgICB9XG4gICAgY29uc3QgYmFzZU51bSA9IE1hdGgucG93KDEwLCBNYXRoLm1heCh0aGlzLmRpZ2l0TGVuZ3RoKG51bTEpLCB0aGlzLmRpZ2l0TGVuZ3RoKG51bTIpKSlcbiAgICByZXR1cm4gKHRoaXMudGltZXMobnVtMSwgYmFzZU51bSkgLSB0aGlzLnRpbWVzKG51bTIsIGJhc2VOdW0pKSAvIGJhc2VOdW1cbiAgfVxuLy8g57K+56Gu6Zmk5rOVXG4gIGRpdmlkZShudW0xLCBudW0yLCAuLi5vdGhlcnMpIHtcbiAgICBpZiAob3RoZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdmlkZSh0aGlzLmRpdmlkZShudW0xLCBudW0yKSwgLi4ub3RoZXJzKVxuICAgIH1cbiAgICBjb25zdCBudW0xQ2hhbmdlID0gdGhpcy5mbG9hdDJGaXhlZChudW0xKVxuICAgIGNvbnN0IG51bTJDaGFuZ2UgPSB0aGlzLmZsb2F0MkZpeGVkKG51bTIpXG4gICAgcmV0dXJuIHRoaXMudGltZXMobnVtMUNoYW5nZSAvIG51bTJDaGFuZ2UsIE1hdGgucG93KDEwLCB0aGlzLmRpZ2l0TGVuZ3RoKG51bTIpIC0gdGhpcy5kaWdpdExlbmd0aChudW0xKSkpXG4gIH1cbiAgLy8g57K+56Gu6Zmk5rOVMlxuICBkaXZpZGUyKGFyZzEsIGFyZzIpIHtcbiAgICBsZXQgdDEgPSAwXG4gICAgbGV0IHQyID0gMFxuICAgIGxldCByMSwgcjJcbiAgICB0cnkge1xuICAgICAgdDEgPSBhcmcxLnRvU3RyaW5nKCkuc3BsaXQoJy4nKVsxXS5sZW5ndGhcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICB0MiA9IGFyZzIudG9TdHJpbmcoKS5zcGxpdCgnLicpWzFdLmxlbmd0aFxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgcjEgPSBOdW1iZXIoYXJnMS50b1N0cmluZygpLnJlcGxhY2UoJy4nLCAnJykpXG4gICAgcjIgPSBOdW1iZXIoYXJnMi50b1N0cmluZygpLnJlcGxhY2UoJy4nLCAnJykpXG4gICAgcmV0dXJuIChyMSAvIHIyKSAqIE1hdGgucG93KDEwLCB0MiAtIHQxKVxuICB9XG4vLyDlm5voiI3kupTlhaXvvIzkuJTkv53nlZnlsI/mlbBcbiAgcm91bmQobnVtLCByYXRpbykge1xuICAgIGNvbnN0IGJhc2UgPSBNYXRoLnBvdygxMCwgcmF0aW8pXG4gICAgcmV0dXJuIHRoaXMuZGl2aWRlKE1hdGgucm91bmQodGhpcy50aW1lcyhudW0sIGJhc2UpKSwgYmFzZSlcbiAgfVxuLy8g5oqK5bCP5pWw6L2s5oiQ5pW05pWw77yM5pSv5oyB56eR5a2m6K6h5pWw5rOV44CC5aaC5p6c5piv5bCP5pWw5YiZ5pS+5aSn5oiQ5pW05pWwXG4gIGZsb2F0MkZpeGVkKG51bSkge1xuICAgIGlmICghfm51bS50b1N0cmluZygpLmluZGV4T2YoJ2UnKSkge1xuICAgICAgcmV0dXJuIE51bWJlcihudW0udG9TdHJpbmcoKS5yZXBsYWNlKCcuJywgJycpKVxuICAgIH1cbiAgICBjb25zdCBkbGVuID0gdGhpcy5kaWdpdExlbmd0aChudW0pXG4gICAgcmV0dXJuIGRsZW4gPiAwID8gbnVtICogTWF0aC5wb3coMTAsIGRsZW4pIDogbnVtXG4gIH1cbi8vIOiOt+WPluW9k+WJjeaVsOWwj+aVsOS9jeeahOmVv+W6pijlpITnkIbnp5HlraborqHmlbDms5XvvIzmnKzotKjkuIrlpITnkIZlLW7nmoTmg4XlhrUpXG4gIGRpZ2l0TGVuZ3RoKG51bSkge1xuICAgIGNvbnN0IGVTcGxpdCA9IG51bS50b1N0cmluZygpLnNwbGl0KC9bZUVdLylcbiAgICBjb25zdCBsZW4gPSAoZVNwbGl0WzBdLnNwbGl0KCcuJylbMV0gfHwgJycpLmxlbmd0aCAtICgrZVNwbGl0WzFdIHx8IDApXG4gICAgcmV0dXJuIGxlbiA+IDAgPyBsZW4gOiAwXG4gIH1cbi8vICDmo4DmtYvmlbDlrZfmmK/lkKbotornlYzvvIzlpoLmnpzotornlYznu5nlh7rmj5DnpLpcbiAgY2hlY2tCb3VuZGFyeShudW0pIHtcbiAgICBpZiAobnVtID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgbnVtIDwgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIGNvbnNvbGUubG9nKGAke251bX0gaXMgYmV5b25kIGJvdW5kYXJ5IHdoZW4gdHJhbnNmZXIgdG8gaW50ZWdlciwgdGhlIHJlc3VsdHMgbWF5IG5vdCBiZSBhY2N1cmF0ZWApXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IFV0aWxzID0ge1xuICBwcmVjaXNpb246IG5ldyBQcmVjaXNpb24oKSxcbiAgLy8g6I635Y+W5bCP5pWw5L2N5pWwXG4gIHJldGFpbkRlY2ltYWxzKHZhbHVlLCBvYmogPSB7fSkge1xuICAgIGlmICghdmFsdWUpIHJldHVybiAwXG4gICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpXG4gICAgaWYgKH52YWx1ZS5pbmRleE9mKCdlJykpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuICAgIGxldCBkZWNpbWFscyA9ICcnXG4gICAgaWYgKHZhbHVlLmluZGV4T2YoJy4nKSA+IDAgJiYgb2JqLmRlY2ltYWwgIT09IDApIHtcbiAgICAgIGxldCBkZWNpbWFsc1JlID0gbmV3IFJlZ0V4cCgnWy5dezF9WzAtOV17MCwnICsgKG9iai5kZWNpbWFsIHx8IDgpICsgJ30nKVxuICAgICAgbGV0IGRlY2ltYWxzRXhlYyA9IGRlY2ltYWxzUmUuZXhlYyh2YWx1ZSlcbiAgICAgIGRlY2ltYWxzRXhlYyAmJiAoZGVjaW1hbHMgPSBkZWNpbWFsc0V4ZWNbMF0pXG4gICAgfVxuICAgIGxldCB2ID0gMFxuICAgIGxldCByZSA9IG5ldyBSZWdFeHAoJ14tP1swLTldezF9WzAtOV17MCwnICsgKG9iai5pbnRlZ2VyIC0gMSB8fCA4KSArICd9JylcbiAgICB2ID0gcmUuZXhlYyh2YWx1ZSlcbiAgICBsZXQgbiA9ICcnXG4gICAgaWYgKHYpIHtcbiAgICAgIG4gPSB2WzBdXG4gICAgfVxuICAgIHJldHVybiBuICsgZGVjaW1hbHNcbiAgfSxcblxuICAvLyDojrflj5blsI/mlbDkvY3mlbBcbiAgcmV0YWluRGVjaW1hbHNXaXRoU3ltYm9sKHZhbHVlLCBvYmogPSB7fSkge1xuICAgIGlmICghdmFsdWUpIHJldHVybiAwXG4gICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpXG4gICAgaWYgKH52YWx1ZS5pbmRleE9mKCdlJykpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuICAgIGxldCBkZWNpbWFscyA9ICcnXG4gICAgaWYgKHZhbHVlLmluZGV4T2YoJy4nKSA+IDAgJiYgb2JqLmRlY2ltYWwgIT09IDApIHtcbiAgICAgIGxldCBkZWNpbWFsc1JlID0gbmV3IFJlZ0V4cCgnWy5dezF9WzAtOV17MCwnICsgKG9iai5kZWNpbWFsIHx8IDgpICsgJ30nKVxuICAgICAgbGV0IGRlY2ltYWxzRXhlYyA9IGRlY2ltYWxzUmUuZXhlYyh2YWx1ZSlcbiAgICAgIGRlY2ltYWxzRXhlYyAmJiAoZGVjaW1hbHMgPSBkZWNpbWFsc0V4ZWNbMF0pXG4gICAgfVxuICAgIGxldCB2ID0gMFxuICAgIGxldCByZSA9IG5ldyBSZWdFeHAoJ14tP1swLTldezF9WzAtOV17MCwnICsgKG9iai5pbnRlZ2VyIC0gMSB8fCA4KSArICd9JylcbiAgICB2ID0gcmUuZXhlYyh2YWx1ZSlcbiAgICBsZXQgbiA9ICcnXG4gICAgaWYgKHYpIHtcbiAgICAgIG4gPSB2WzBdXG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBuICsgZGVjaW1hbHNcbiAgICBpZiAoTnVtYmVyKHJlc3VsdCkgPCAwKSB7XG4gICAgICByZXR1cm4gbiArIGRlY2ltYWxzXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAnKycgKyBuICsgZGVjaW1hbHNcbiAgICB9XG4gIH0sXG4gIC8vIOaVsOWtl+WKoOmAl+WPt1xuICBudW1iZXJGb3JtYXQobnVtKSB7XG4gICAgaWYgKG51bSkge1xuICAgICAgbGV0IFtudW0xLCBudW0yXSA9IG51bS50b1N0cmluZygpLnNwbGl0KCcuJylcbiAgICAgIG51bTEgPSBudW0xLnNwbGl0KCcnKS5yZXZlcnNlKCkubWFwKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICByZXR1cm4gKGluZGV4KSAlIDMgfHwgIWluZGV4IHx8IGl0ZW0gPT09ICctJyB8fCBpdGVtID09PSAnKycgPyBpdGVtIDogaXRlbSArICcsJ1xuICAgICAgfSkucmV2ZXJzZSgpLmpvaW4oJycpXG4gICAgICBudW0yID8gbnVtID0gbnVtMSArICcuJyArIG51bTIgOiBudW0gPSBudW0xXG4gICAgfVxuICAgIHJldHVybiBudW1cbiAgfSxcbiAgLy8g6KGl5YWFMFxuICBzcGxpdEZvcm1hdChudW0sIGZyYWN0aW9uRGlnaXRzLCBsZW4pIHtcbiAgICBpZiAoaXNOYU4obnVtKSkgcmV0dXJuIG51bVxuICAgIGlmIChudW0pIHtcbiAgICAgIGlmIChudW0gPT09ICcwJykge1xuICAgICAgICByZXR1cm4gbnVtXG4gICAgICB9XG4gICAgICBsZXQgZGlnaXQgPSBudW0udG9TdHJpbmcoKS5zcGxpdCgnLicpXG4gICAgICBpZiAoZnJhY3Rpb25EaWdpdHMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGRpZ2l0WzBdXG4gICAgICB9XG4gICAgICBpZiAoZGlnaXQubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAoZnJhY3Rpb25EaWdpdHMgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZGlnaXRbMF1cbiAgICAgICAgfSBlbHNlIGlmIChkaWdpdFsxXS5sZW5ndGggPCBmcmFjdGlvbkRpZ2l0cykge1xuICAgICAgICAgIGxldCBkaWdpdFJlc3VsdCA9ICcnXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFjdGlvbkRpZ2l0cyAtIGRpZ2l0WzFdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkaWdpdFJlc3VsdCArPSAnMCdcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bSArIGRpZ2l0UmVzdWx0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IGRpZ2l0UmVzdWx0ID0gZGlnaXRbMV0uc3Vic3RyaW5nKDAsIGxlbiB8fCBmcmFjdGlvbkRpZ2l0cylcbiAgICAgICAgICByZXR1cm4gZGlnaXRbMF0gKyAnLicgKyBkaWdpdFJlc3VsdFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZGlnaXRSZXN1bHQgPSAnLidcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFjdGlvbkRpZ2l0czsgaSsrKSB7XG4gICAgICAgICAgZGlnaXRSZXN1bHQgKz0gJzAnXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bSArIGRpZ2l0UmVzdWx0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudW1cbiAgICB9XG4gIH0sXG4gIC8vIOS9jeaVsOS4jeWkn+ihpTBcbiAgYWRkWmVybyhudW0sIGxlbikge1xuICAgIGlmIChpc05hTihudW0pKSByZXR1cm4gMFxuICAgIGxldCBzdHIgPSBTdHJpbmcobnVtKVxuICAgIC8vIGNvbnNvbGUubG9nKG51bSwgbGVuKVxuICAgIHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKG5ldyBSZWdFeHAoYF4oXFxcXC0/KShcXFxcZCspKFxcXFwuXFxcXGR7MSwke2xlbn19KT9gKSwgKG4sIGEsIGIsIGMpID0+IHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGEsIGIsIGMpXG4gICAgICBsZXQgc3RyID0gYSArIGIgLy8gLnJlcGxhY2UoLyhcXGQpKD89KD86XFxkezN9KSskKS9nLCAnJDEsJylcbiAgICAgIGlmICghbGVuKSB7XG4gICAgICAgIHJldHVybiBzdHJcbiAgICAgIH1cbiAgICAgIGlmIChjKSB7XG4gICAgICAgIHN0ciArPSBjICsgcmVwZWF0KCcwJywgbGVuIC0gYy5sZW5ndGgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgKz0gJy4nICsgcmVwZWF0KCcwJywgbGVuKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0clxuICAgIH0pXG4gIH0sXG4gIC8vIOaVsOWtl+WKoOmAl+WPt1xuICBhZGRDb21tb20obnVtLCBsZW4pIHtcbiAgICBpZiAoaXNOYU4obnVtKSB8fCAhbnVtKSByZXR1cm4gbnVtXG4gICAgbnVtID0gU3RyaW5nKG51bSlcbiAgICBpZiAoIWlzTmFOKGxlbikpIHtcbiAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgbnVtID0gbnVtLnNwbGl0KCcuJylbMF1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudW0ucmVwbGFjZSgvKFxcZCspKFxcLlxcZCspPy8sIChhLCBiLCBjKSA9PiB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGIsIGMpXG4gICAgICAgIHJldHVybiBiLnJlcGxhY2UoLyhcXGQpKD89KD86XFxkezN9KSskKS9nLCAnJDEsJykgKyAoYyA/IGMuc2xpY2UoMCwgbGVuICsgMSkgOiAnJylcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudW0ucmVwbGFjZSgvXlxcZCsvLCAoYSkgPT4geyByZXR1cm4gYS5yZXBsYWNlKC8oXFxkKSg/PSg/OlxcZHszfSkrJCkvZywgJyQxLCcpIH0pXG4gICAgfVxuICB9LFxuICAvLyDojrflj5bml7bpl7TlubTmnIjml6Ug5pe25YiG56eSXG4gIHRpbWVGb3JtYXQodGltZSwgdHlwZSkge1xuICAgIGxldCBkYXRlID0gZ2V0VGltZVpvbmUodGltZSlcbiAgICBpZiAoIXR5cGUpIHJldHVybiBnZXRZTUQoZGF0ZSkgKyAnICcgKyBnZXRITVMoZGF0ZSlcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ0hNUyc6IHJldHVybiBnZXRITVMoZGF0ZSlcbiAgICAgIGNhc2UgJ1lNRCc6IHJldHVybiBnZXRZTUQoZGF0ZSlcbiAgICB9XG4gIH0sXG4gIGNzc1Byb3BlcnR5KGF0dHIpIHtcbiAgICB2YXIgcHJlZml4ID0gWyAnTycsICdtcycsICdNb3onLCAnV2Via2l0JyBdXG4gICAgdmFyIGxlbiA9IHByZWZpeC5sZW5ndGhcbiAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpJykuc3R5bGVcbiAgICBpZiAoYXR0ciBpbiBzdHlsZSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgYXR0ciA9IGF0dHIucmVwbGFjZSgvXlthLXpdLywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuIHZhbC50b1VwcGVyQ2FzZSgpXG4gICAgfSlcbiAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgIGlmIChwcmVmaXhbIGxlbiBdICsgYXR0ciBpbiBzdHlsZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfSxcbiAgLyoqXG4gKiDpmLLlj43ot7PjgIJmdW5j5Ye95pWw5Zyo5pyA5ZCO5LiA5qyh6LCD55So5pe25Yi755qEd2FpdOavq+enkuS5i+WQjuaJp+ihjO+8gVxuICogQHBhcmFtIGZ1bmMg5omn6KGM5Ye95pWwXG4gKiBAcGFyYW0gd2FpdCDml7bpl7Tpl7TpmpRcbiAqIEBwYXJhbSBpbW1lZGlhdGUg5Li6dHJ1ZSwgZGVib3VuY2XkvJrlnKh3YWl05pe26Ze06Ze06ZqU55qE5byA5aeL6LCD55So6L+Z5Liq5Ye95pWwXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbiAgZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0XG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxhc3QgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRpbWVzdGFtcCAvLyB0aW1lc3RhbXDkvJrlrp7ml7bmm7TmlrBcbiAgICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZW91dCA9IG51bGxcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpXG4gICAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgY29udGV4dCA9IHRoaXNcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHNcbiAgICAgIHRpbWVzdGFtcCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dFxuICAgICAgaWYgKCF0aW1lb3V0KSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KVxuICAgICAgfVxuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKVxuICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGxcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gIH1cbn1cbiAgLy8g5a2X56ym5Liy5aSN5Yi2XG5mdW5jdGlvbiByZXBlYXQodGFyZ2V0LCBuKSB7XG4gIHZhciBzID0gJydcbiAgd2hpbGUgKG4gPiAwKSB7XG4gICAgaWYgKG4gJSAyID09PSAxKSB7XG4gICAgICBzICs9IHRhcmdldFxuICAgIH1cbiAgICBpZiAobiA9PT0gMSkgeyBicmVhayB9XG4gICAgdGFyZ2V0ICs9IHRhcmdldFxuICAgIG4gPSBuID4+IDFcbiAgfVxuICByZXR1cm4gc1xufVxuZnVuY3Rpb24gc2luZ2xlRm9ybWF0KHN0cikge1xuICByZXR1cm4gc3RyLnRvU3RyaW5nKCkubGVuZ3RoID09PSAxID8gKCcwJyArIHN0cikgOiBzdHJcbn1cblxuZnVuY3Rpb24gZ2V0WU1EKHRpbWUpIHtcbiAgbGV0IHllYXIgPSB0aW1lLmdldEZ1bGxZZWFyKClcbiAgbGV0IG1vbnRoID0gdGltZS5nZXRNb250aCgpICsgMVxuICBsZXQgZGF0ZSA9IHRpbWUuZ2V0RGF0ZSgpXG4gIHJldHVybiB5ZWFyICsgJy0nICsgc2luZ2xlRm9ybWF0KG1vbnRoKSArICctJyArIHNpbmdsZUZvcm1hdChkYXRlKVxufVxuXG5mdW5jdGlvbiBnZXRITVModGltZSkge1xuICBsZXQgaG91cnMgPSB0aW1lLmdldEhvdXJzKClcbiAgbGV0IG1pbnV0ZXMgPSB0aW1lLmdldE1pbnV0ZXMoKVxuICBsZXQgc2Vjb25kcyA9IHRpbWUuZ2V0U2Vjb25kcygpXG4gIHJldHVybiBzaW5nbGVGb3JtYXQoaG91cnMpICsgJzonICsgc2luZ2xlRm9ybWF0KG1pbnV0ZXMpICsgJzonICsgc2luZ2xlRm9ybWF0KHNlY29uZHMpXG59XG5mdW5jdGlvbiBnZXRUaW1lWm9uZSh0aW1lKSB7XG4gIGxldCBHVE1fOCA9IDQ4MCAgLy8gLTQ4MFxuICBsZXQgZGF0ZSA9IG5ldyBEYXRlKHRpbWUpXG4gIGxldCBzdWJNaW4gPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKyBHVE1fOFxuICBkYXRlLnNldE1pbnV0ZXMoZGF0ZS5nZXRNaW51dGVzKCkgKyBzdWJNaW4pXG4gIHJldHVybiBkYXRlXG59XG5cbmV4cG9ydCBkZWZhdWx0IFV0aWxzXG4iLCIgIC8vIElzUmV2ZXJzZSDmmK/lkKbmmK/lj43lkJHlkIjnuqZcbiAgZnVuY3Rpb24gSXNSZXZlcnNlKFF1b3RlQ29pbiwgUHJpY2VDb2luKSB7XG4gICAgcmV0dXJuIFF1b3RlQ29pbiA9PT0gUHJpY2VDb2luXG4gIH1cbiAgLy8gTWFyZ2luQ29pbiDkv53or4Hph5HluIFcbiAgZnVuY3Rpb24gTWFyZ2luQ29pbihCYXNlQ29pbiwgUXVvdGVDb2luLCBQcmljZUNvaW4pIHtcbiAgICByZXR1cm4gSXNSZXZlcnNlKFF1b3RlQ29pbiwgUHJpY2VDb2luKSA/IEJhc2VDb2luIDogUXVvdGVDb2luXG4gIH1cbiAgZXhwb3J0IHtJc1JldmVyc2UsIE1hcmdpbkNvaW59XG4iLCIgIGltcG9ydCB7IElzUmV2ZXJzZSB9IGZyb20gJy4vY29tbW9uJ1xuICBpbXBvcnQgVXRpbCBmcm9tICcuLi91dGlsJ1xuICAvLyBDYWxjdWxhdGVDb250cmFjdFZhbHVlIOmAmui/h+mHj+WSjOS7t+agvOiuoeeul+WQiOe6puS7t+WAvFxuICAvLyB2b2w66YePXG4gIC8vIHByaWNlOuS7t+agvFxuICAvLyBjb250cmFjdDrlkIjnuqbkv6Hmga9cbiAgZnVuY3Rpb24gQ2FsY3VsYXRlQ29udHJhY3RWYWx1ZSh2b2wsIHByaWNlLCBDb250cmFjdCkge1xuICAgIHJldHVybiBjYWxjdWxhdGVDb250cmFjdFZhbHVlKHZvbCwgcHJpY2UsIENvbnRyYWN0LmNvbnRyYWN0U2l6ZSwgSXNSZXZlcnNlKENvbnRyYWN0LnF1b3RlQ29pbiwgQ29udHJhY3QucHJpY2VDb2luKSlcbiAgfVxuICBmdW5jdGlvbiBjYWxjdWxhdGVDb250cmFjdFZhbHVlKHZvbCwgcHJpY2UsIGNvbnRyYWN0U2l6ZSwgaXNSZXZlcnNlKSB7XG4gICAgbGV0IGFtb3VudCA9IDBcbiAgICBpZiAodm9sIDw9IDAgfHwgcHJpY2UgPT09IDAgfHwgY29udHJhY3RTaXplIDw9IDApIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuICAgIGlmIChpc1JldmVyc2UpIHtcbiAgICAgIGFtb3VudCA9IFV0aWwucHJlY2lzaW9uLmRpdmlkZShVdGlsLnByZWNpc2lvbi50aW1lcyh2b2wsIGNvbnRyYWN0U2l6ZSksIHByaWNlKVxuICAgIH0gZWxzZSB7XG4gICAgICBhbW91bnQgPSBVdGlsLnByZWNpc2lvbi50aW1lcyh2b2wsIGNvbnRyYWN0U2l6ZSwgcHJpY2UpXG4gICAgfVxuICAgIHJldHVybiBhbW91bnRcbiAgfVxuICAvLyBDYWxjdWxhdGVRdW90ZVByaWNlIOmAmui/h+S7t+WAvOWSjOmHj+iuoeeul+S7t+agvFxuICAvLyB2YWx1ZTrku7flgLxcbiAgLy8gdm9sOumHj1xuICAvLyBjb250cmFjdDrlkIjnuqZcbiAgZnVuY3Rpb24gQ2FsY3VsYXRlUXVvdGVQcmljZSh2YWx1ZSwgdm9sLCBjb250cmFjdCkge1xuICAgIGlmICghY29udHJhY3QpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuICAgIHJldHVybiBjYWxjdWxhdGVRdW90ZVByaWNlKHZhbHVlLCB2b2wsIGNvbnRyYWN0LmNvbnRyYWN0U2l6ZSwgSXNSZXZlcnNlKGNvbnRyYWN0LnF1b3RlQ29pbiwgY29udHJhY3QucHJpY2VDb2luKSlcbiAgfVxuICBmdW5jdGlvbiBjYWxjdWxhdGVRdW90ZVByaWNlKHZhbHVlLCB2b2wsIGNvbnRyYWN0U2l6ZSwgaXNSZXZlcnNlKSB7XG4gICAgbGV0IHByaWNlXG4gICAgaWYgKGNvbnRyYWN0U2l6ZSA8PSAwKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgICBpZiAoaXNSZXZlcnNlKSB7XG4gICAgICBpZiAodmFsdWUgPD0gMCkge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfVxuICAgICAgcHJpY2UgPSB2b2wgKiBjb250cmFjdFNpemUgLyB2YWx1ZVxuICAgICAgcmV0dXJuIHByaWNlXG4gICAgfVxuICAgIGlmICh2b2wgPD0gMCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gICAgcHJpY2UgPSB2YWx1ZSAvIHZvbCAvIGNvbnRyYWN0U2l6ZVxuICAgIHJldHVybiBwcmljZVxuICB9XG4gIC8vIENhbGN1bGF0ZUNvbnRyYWN0QmFzaWNWYWx1ZSDpgJrov4fph4/lkozku7fmoLzorqHnrpflkIjnuqbnmoTln7rnoYDmr5Tku7flgLxcbiAgLy8gY29pblVuaXQgdHJ1ZSAg6L+U5Zue5YC85Y2V5L2N5Li65bygICBmYWxzZSDljZXkvY3lkoxCYXNlQ29pbuWNleS9jeS4gOiHtFxuICBmdW5jdGlvbiBDYWxjdWxhdGVDb250cmFjdEJhc2ljVmFsdWUodm9sLCBwcmljZSwgY29udHJhY3QsIGNvaW5Vbml0KSB7XG4gICAgLy8gY29uc29sZS5sb2coNjYpXG4gICAgbGV0IGFtb3VudCA9IDBcbiAgICBpZiAodm9sIDw9IDAgfHwgcHJpY2UgPD0gMCB8fCAhY29udHJhY3QpIHtcbiAgICAgIHJldHVybiBhbW91bnRcbiAgICB9XG4gICAgYW1vdW50ID0gdm9sXG4gICAgaWYgKElzUmV2ZXJzZShjb250cmFjdC5xdW90ZUNvaW4sIGNvbnRyYWN0LnByaWNlQ29pbikpIHtcbiAgICAgIGFtb3VudCA9IGNvaW5Vbml0ID8gTWF0aC5mbG9vcihhbW91bnQgKiBwcmljZSAvIGNvbnRyYWN0LmNvbnRyYWN0U2l6ZSkgOiBhbW91bnQgLyBwcmljZSAqIGNvbnRyYWN0LmNvbnRyYWN0U2l6ZVxuICAgICAgcmV0dXJuIGFtb3VudFxuICAgIH1cbiAgICByZXR1cm4gY29pblVuaXQgPyBNYXRoLmZsb29yKGFtb3VudCAvIGNvbnRyYWN0LmNvbnRyYWN0U2l6ZSkgOiBVdGlsLnByZWNpc2lvbi50aW1lcyhhbW91bnQsIGNvbnRyYWN0LmNvbnRyYWN0U2l6ZSlcbiAgfVxuXG4gICAgLy8gQ2FsY3VsYXRlQ29udHJhY3RCYXNpY1ZhbHVlIOmAmui/h+mHj+WSjOS7t+agvOiuoeeul+WQiOe6pueahOWfuuehgOavlOS7t+WAvFxuICAvLyDmiorlvKDmjaLmiJBtcmdpbkNvaW5cbiAgZnVuY3Rpb24gQ2FsY3VsYXRlQ29udHJhY3RCYXNpY1ZhbHVlVHdvKHZvbCwgcHJpY2UsIGNvbnRyYWN0KSB7XG4gICAgbGV0IGFtb3VudCA9IDBcbiAgICBpZiAodm9sIDw9IDAgfHwgcHJpY2UgPD0gMCB8fCAhY29udHJhY3QpIHtcbiAgICAgIHJldHVybiBhbW91bnRcbiAgICB9XG4gICAgYW1vdW50ID0gdm9sXG4gICAgaWYgKElzUmV2ZXJzZShjb250cmFjdC5xdW90ZUNvaW4sIGNvbnRyYWN0LnByaWNlQ29pbikpIHtcbiAgICAgIHJldHVybiBhbW91bnQgLyBwcmljZSAqIGNvbnRyYWN0LmNvbnRyYWN0U2l6ZVxuICAgIH1cbiAgICByZXR1cm4gYW1vdW50ICogY29udHJhY3QuY29udHJhY3RTaXplICogcHJpY2VcbiAgfVxuXG4gIGV4cG9ydCB7Q2FsY3VsYXRlQ29udHJhY3RWYWx1ZSwgQ2FsY3VsYXRlUXVvdGVQcmljZSwgQ2FsY3VsYXRlQ29udHJhY3RCYXNpY1ZhbHVlLCBDYWxjdWxhdGVDb250cmFjdEJhc2ljVmFsdWVUd299XG4iLCIgIGltcG9ydCB7IENhbGN1bGF0ZUNvbnRyYWN0VmFsdWUgfSBmcm9tICcuL3ZhbHVlJ1xuICAvLyBDYWxjdWxhdGVNTVIg6K6h566X57u05oyB5L+d6K+B6YeR546HXG4gIGZ1bmN0aW9uIENhbGN1bGF0ZU1NUih2YWx1ZSwgcmlza0xpbWl0KSB7XG4gICAgaWYgKHZhbHVlIDw9IHJpc2tMaW1pdC5CYXNlTGltaXQgfHwgcmlza0xpbWl0LlN0ZXAgPD0gMCkge1xuICAgICAgcmV0dXJuIHJpc2tMaW1pdC5NYWludGVuYW5jZU1hcmdpblxuICAgIH1cbiAgICBsZXQgc3RlcFZhbHVlID0gdmFsdWUgLSByaXNrTGltaXQuQmFzZUxpbWl0XG4gICAgbGV0IHN0ZXBzQ291bnQgPSBNYXRoLmNlaWwoc3RlcFZhbHVlIC8gcmlza0xpbWl0LlN0ZXApXG4gICAgbGV0IE1NUiA9IHJpc2tMaW1pdC5NYWludGVuYW5jZU1hcmdpbiAqIChzdGVwc0NvdW50ICsgMSlcbiAgICAvLyDlpKfkuo4wLjVcbiAgICBpZiAoTU1SID4gMC41KSB7XG4gICAgICByZXR1cm4gMC41XG4gICAgfVxuICAgIHJldHVybiBNTVJcbiAgfVxuICAvLyBDYWxjdWxhdGVNTSDorqHnrpfnu7TmjIHkv53or4Hph5FcbiAgZnVuY3Rpb24gQ2FsY3VsYXRlTU0odmFsdWUsIHJpc2tMaW1pdCkge1xuICAgIGxldCBNTVJcbiAgICBpZiAodmFsdWUgPD0gMCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gICAgTU1SID0gQ2FsY3VsYXRlTU1SKHZhbHVlLCByaXNrTGltaXQpXG4gICAgcmV0dXJuIHZhbHVlICogTU1SXG4gIH1cbiAgLy8gQ2FsY3VsYXRlSU1SIOiuoeeul+W8gOS7k+S/neivgemHkeeOh1xuICBmdW5jdGlvbiBDYWxjdWxhdGVJTVIodmFsdWUsIHJpc2tMaW1pdCkge1xuICAgIGlmICh2YWx1ZSA8IHJpc2tMaW1pdC5CYXNlTGltaXQgfHwgcmlza0xpbWl0LlN0ZXAgPD0gMCkge1xuICAgICAgcmV0dXJuIHJpc2tMaW1pdC5Jbml0aWFsTWFyZ2luXG4gICAgfVxuICAgIGxldCBJTVIgPSAoTWF0aC5jZWlsKCh2YWx1ZSAtIHJpc2tMaW1pdC5CYXNlTGltaXQpIC8gcmlza0xpbWl0LlN0ZXApICsgMSkgKiByaXNrTGltaXQuSW5pdGlhbE1hcmdpblxuICAgIHJldHVybiBJTVIgPiAxID8gMSA6IElNUlxuICB9XG4gIC8vIENhbGN1bGF0ZU1hcmtldE9yZGVySU1SIOmAmui/h+eUqOaIt+i1hOS6p+iuoeeul+eUqOaIt+Wwhui1hOS6p+WFqOmDqOW8gOW4guS7t+WNleaXtueahOW8gOS7k+S/neivgemHkeeOh1xuICAvLyBhc3NldDrnlKjmiLfotYTkuqdcbiAgLy8gYWR2YW5jZTrnlKjmiLfnmoTlt7Lmj5DkuqTlp5TmiZjorqLljZXku7flgLxcbiAgLy8gcG9zaXRpb24655So5oi35LuT5L2NXG4gIC8vIGNvbnRyYWN0SW5mbzrlkIjnuqbkv6Hmga9cbiAgZnVuY3Rpb24gQ2FsY3VsYXRlTWFya2V0T3JkZXJJTVIoYXNzZXQsIGFkdmFuY2UsIHBvc2l0aW9uLCBjb250cmFjdEluZm8sIHdheSkge1xuICAgIGxldCBhZHZhbmNlVmFsdWUgPSAwXG4gICAgbGV0IGhvbGRWYWx1ZSA9IDBcbiAgICBsZXQgcHJlVmFsdWUgPSAwXG4gICAgbGV0IElNUiwgSU1SMlxuICAgIGxldCB0YWtlRmVlUmF0aW8gPSBjb250cmFjdEluZm8uRmVlQ29uZmlnLlRha2VyRmVlXG4gICAgaWYgKGFkdmFuY2UgJiYgYWR2YW5jZS5Wb2wpIHtcbiAgICAgIGFkdmFuY2VWYWx1ZSA9IENhbGN1bGF0ZUNvbnRyYWN0VmFsdWUoYWR2YW5jZS5Wb2wsIGFkdmFuY2UuQW1vdW50IC8gYWR2YW5jZS5Wb2wsIGNvbnRyYWN0SW5mby5Db250cmFjdClcbiAgICB9XG4gICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICBob2xkVmFsdWUgPSBDYWxjdWxhdGVDb250cmFjdFZhbHVlKHBvc2l0aW9uLkhvbGRWb2wsIHBvc2l0aW9uLkhvbGRBdmdQcmljZSwgY29udHJhY3RJbmZvLkNvbnRyYWN0KVxuICAgIH1cbiAgICBwcmVWYWx1ZSA9IGFkdmFuY2VWYWx1ZSArIGhvbGRWYWx1ZVxuICAgIGxldCBpID0gMFxuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIElNUiA9IGNvbnRyYWN0SW5mby5SaXNrTGltaXQuSW5pdGlhbE1hcmdpbiAqIGlcbiAgICAgIElNUjIgPSBDYWxjdWxhdGVJTVIoYXNzZXQgLyAoSU1SICsgMiAqIHRha2VGZWVSYXRpbyArICh3YXkgPyAwIDogdGFrZUZlZVJhdGlvICogSU1SKSkgKyBwcmVWYWx1ZSwgY29udHJhY3RJbmZvLlJpc2tMaW1pdClcbiAgICAgIGlmIChJTVIgPj0gSU1SMikge1xuICAgICAgICByZXR1cm4gSU1SXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGV4cG9ydCB7Q2FsY3VsYXRlTU1SLCBDYWxjdWxhdGVJTVIsIENhbGN1bGF0ZU1hcmtldE9yZGVySU1SLCBDYWxjdWxhdGVNTX1cbiIsIiAgaW1wb3J0IHsgQ2FsY3VsYXRlQ29udHJhY3RWYWx1ZSB9IGZyb20gJy4vdmFsdWUnXG4gIGltcG9ydCB7IENhbGN1bGF0ZUlNUiB9IGZyb20gJy4vbWFyZ2luJ1xuICAvLyBDYWxjdWxhdGVBZHZhbmNlT3BlbkNvc3Qg5o+Q5Lqk5byA5LuT6K6i5Y2V5pe2LOiuoeeul+mihOW8gOS7k+aIkOacrFxuICAvLyBvcmRlcjrorqLljZXkv6Hmga9cbiAgLy8gcG9zaXRpb24655So5oi35oyB5pyJ5LuT5L2NXG4gIC8vIG9wZW5PcmRlclNpemU65bey5o+Q5Lqk55qE5aeU5omY6K6i5Y2V5aSn5bCPXG4gIC8vIGNvbnRyYWN0SW5mbzrlkIjnuqbkv6Hmga9cbiAgLy8gd2F5IOaYr+WQpuW8gOWkmiB0cmF1ZSA6IGZhbHNlXG4gIGZ1bmN0aW9uIENhbGN1bGF0ZUFkdmFuY2VPcGVuQ29zdChvcmRlciwgcG9zaXRpb24sIG9wZW5PcmRlclNpemUsIENvbnRyYWN0LCBSaXNrTGltaXQsIHdheSkge1xuICAgIGlmIChvcmRlci5Wb2wgPD0gMCB8fCBvcmRlci5QcmljZSA8PSAwKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgICBsZXQgaG9sZFZvbCA9IDBcbiAgICBsZXQgaG9sZEF2Z1ByaWNlID0gMFxuICAgIGxldCBhZHZhbmNlVm9sID0gMFxuICAgIGxldCBhZHZhbmNlUHJpY2UgPSAwXG4gICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICBob2xkVm9sID0gcG9zaXRpb24uSG9sZFZvbFxuICAgICAgaG9sZEF2Z1ByaWNlID0gcG9zaXRpb24uSG9sZEF2Z1ByaWNlXG4gICAgfVxuICAgIGlmIChvcGVuT3JkZXJTaXplICYmIG9wZW5PcmRlclNpemUuVm9sID4gMCkge1xuICAgICAgYWR2YW5jZVZvbCA9IG9wZW5PcmRlclNpemUuVm9sXG4gICAgICBhZHZhbmNlUHJpY2UgPSBvcGVuT3JkZXJTaXplLkFtb3VudCAvIG9wZW5PcmRlclNpemUuVm9sXG4gICAgfVxuICAgIHJldHVybiBfY2FsY3VsYXRlQWR2YW5jZU9wZW5Db3N0KGhvbGRWb2wsIGFkdmFuY2VWb2wsIGhvbGRBdmdQcmljZSwgYWR2YW5jZVByaWNlLCBvcmRlciwgQ29udHJhY3QsIFJpc2tMaW1pdCwgd2F5KVxuICB9XG4gIGZ1bmN0aW9uIF9jYWxjdWxhdGVBZHZhbmNlT3BlbkNvc3QoaG9sZFZvbCwgYWR2YW5jZVZvbCwgaG9sZEF2Z1ByaWNlLCBhZHZhbmNlUHJpY2UsIG9yZGVyLCBDb250cmFjdCwgUmlza0xpbWl0LCB3YXkpIHtcbiAgICBsZXQgb3JkZXJWYWx1ZSA9IENhbGN1bGF0ZUNvbnRyYWN0VmFsdWUob3JkZXIuVm9sLCBvcmRlci5QcmljZSwgQ29udHJhY3QpXG4gICAgbGV0IGFkdmFuY2VWYWx1ZSA9IENhbGN1bGF0ZUNvbnRyYWN0VmFsdWUoYWR2YW5jZVZvbCwgYWR2YW5jZVByaWNlLCBDb250cmFjdClcbiAgICBsZXQgaG9sZFZhbHVlID0gQ2FsY3VsYXRlQ29udHJhY3RWYWx1ZShob2xkVm9sLCBob2xkQXZnUHJpY2UsIENvbnRyYWN0KVxuICAgIGxldCB0b3RhbFZhbHVlID0gb3JkZXJWYWx1ZSArIGFkdmFuY2VWYWx1ZSArIGhvbGRWYWx1ZVxuICAgIC8vIOW8gOS7k+S/neivgemHkeeOh1xuICAgIG9yZGVyLklNUiA9IENhbGN1bGF0ZUlNUih0b3RhbFZhbHVlLCBSaXNrTGltaXQpXG4gICAgaWYgKG9yZGVyLkxldmVyYWdlID4gMCkge1xuICAgICAgbGV0IGxldmVyYWdlSU1SID0gMSAvIG9yZGVyLkxldmVyYWdlXG4gICAgICBpZiAobGV2ZXJhZ2VJTVIgPiBvcmRlci5JTVIpIHtcbiAgICAgICAgb3JkZXIuSU1SID0gbGV2ZXJhZ2VJTVJcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IElNID0gb3JkZXJWYWx1ZSAqIG9yZGVyLklNUlxuICAgIGxldCBicmFua3J1cHRUYWtlRmVlID0gb3JkZXJWYWx1ZSAqIEJUUih3YXksIG9yZGVyLlRha2VGZWVSYXRpbywgb3JkZXIuSU1SKVxuICAgIGxldCBNYXhUYWtlRmVlID0gb3JkZXJWYWx1ZSAqIG9yZGVyLlRha2VGZWVSYXRpbyArIGJyYW5rcnVwdFRha2VGZWVcbiAgICBsZXQgRnJlZXpBc3NldHMgPSBJTSArIE1heFRha2VGZWVcbiAgICByZXR1cm4gRnJlZXpBc3NldHNcbiAgfVxuICAvLyDmmK/lkKblvIDlpJrljZVcbiAgLy8gQlRSIOiOt+WPluiuouWNleegtOS6p+aXtueahHRha2VGZWVSYXRpb1xuICBmdW5jdGlvbiBCVFIod2F5LCBUYWtlRmVlUmF0aW8sIElNUikge1xuICAgIHJldHVybiB3YXkgPyBUYWtlRmVlUmF0aW8gOiAoVGFrZUZlZVJhdGlvICogKDEgKyBJTVIpKVxuICB9XG4gIGV4cG9ydCBkZWZhdWx0IENhbGN1bGF0ZUFkdmFuY2VPcGVuQ29zdFxuIiwiaW1wb3J0IHsgQ2FsY3VsYXRlTWFya2V0T3JkZXJJTVIgfSBmcm9tICcuL21hcmdpbidcbmltcG9ydCB7IENhbGN1bGF0ZUNvbnRyYWN0VmFsdWUgfSBmcm9tICcuL3ZhbHVlJ1xuaW1wb3J0IHsgSXNSZXZlcnNlIH0gZnJvbSAnLi9jb21tb24nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLeiuoeeul+W4guS7t+WPr+W8gOWkmuWwkeW8oCAtLS0tLS0tLS0tLS0tLS0tLS1cbi8vIENhbGN1bGF0ZVZvbHVtZSDpgJrov4fotYTkuqflkozku7fmoLws6K6h566X6YePXG4vLyBhc3NldDrotYTkuqdcbi8vIGFkdmFuY2U655So5oi355qE5bey5o+Q5Lqk5aeU5omY6K6i5Y2V5Lu35YC8XG4vLyBwb3NpdGlvbjrnlKjmiLfku5PkvY1cbi8vIHByaWNlOuS7t+agvFxuLy8gd2F5OuW8gOS7k+exu+WeiyzmmK/lvIDlpJos6L+Y5piv5byA56m6XG4vLyBjb250cmFjdEluZm865ZCI57qm5L+h5oGvXG4vLyBsZXZlcmFnZSDmnaDmnYZcbmZ1bmN0aW9uIENhbGN1bGF0ZVZvbHVtZShhc3NldCwgYWR2YW5jZSwgcG9zaXRpb24sIHByaWNlLCBjb250cmFjdEluZm8sIHdheSwgbGV2ZXJhZ2UpIHtcbiAgaWYgKGFzc2V0IDw9IDApIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGxldCBJTVIsIHRha2VGZWVSYXRpbywgYmFua3J1cHRUYWtlRmVlUmF0aW8sIE0sIElNUlRcbiAgSU1SVCA9IENhbGN1bGF0ZU1hcmtldE9yZGVySU1SKGFzc2V0LCBhZHZhbmNlLCBwb3NpdGlvbiwgY29udHJhY3RJbmZvLCB3YXkpXG4gIElNUiA9IE1hdGgubWF4KElNUlQsIDEgLyBsZXZlcmFnZSlcblxuICB0YWtlRmVlUmF0aW8gPSBjb250cmFjdEluZm8uRmVlQ29uZmlnLlRha2VyRmVlXG4gIGJhbmtydXB0VGFrZUZlZVJhdGlvID0gdGFrZUZlZVJhdGlvXG4gIGlmICghd2F5KSB7IC8vIOW8gOepulxuICAgIGJhbmtydXB0VGFrZUZlZVJhdGlvID0gdGFrZUZlZVJhdGlvICogKDEgKyBJTVIpXG4gIH1cbiAgLy8g56m65LuTIGJhbmtydXB0VGFrZUZlZVJhdGlvID0gQlRSID0gICgxK0lNUikqVFJcbiAgLy8g5aSa5LuTIGJhbmtydXB0VGFrZUZlZVJhdGlvID0gVFJcbiAgLy8gQSA9IHZvbCAqIHAgKiBzICogW0lNUiArIFRSICsgQlRSXVxuICBsZXQgaXNSID0gSXNSZXZlcnNlKGNvbnRyYWN0SW5mby5Db250cmFjdC5xdW90ZUNvaW4sIGNvbnRyYWN0SW5mby5Db250cmFjdC5wcmljZUNvaW4pIC8vIGFzc2V0ID0gdm9sICogcHJpY2UqcyooSU1SKzIqdGFrZUZlZVJhdGlvKVxuICAgICAgLy8gYXNzZXQgPSB2b2wqcyooSU1SKzIqdGFrZUZlZVJhdGlvKS9wcmljZVxuICAgIC8vIEQgPSBhc3NldCAqIHByaWNlXG4gICAgLy8gTSA9IHMqKElNUisyKnRha2VGZWVSYXRpbylcbiAgTSA9IGNvbnRyYWN0SW5mby5Db250cmFjdC5jb250cmFjdFNpemUgKiAoSU1SICsgdGFrZUZlZVJhdGlvICsgYmFua3J1cHRUYWtlRmVlUmF0aW8pXG4gIGlmIChNIDw9IDApIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIHByaWNlID0gaXNSID8gcHJpY2UgOiAxIC8gcHJpY2VcbiAgbGV0IG1heCA9IE1hdGguZmxvb3IoYXNzZXQgKiBwcmljZSAvIE0pXG4gIGlmIChJTVIgPiBjb250cmFjdEluZm8uUmlza0xpbWl0LkluaXRpYWxNYXJnaW4pIHtcbiAgICBsZXQgYWR2YW5jZVZhbHVlID0gMFxuICAgIGxldCBob2xkVmFsdWUgPSAwXG4gICAgaWYgKGFkdmFuY2UgJiYgYWR2YW5jZS5Wb2wpIHtcbiAgICAgIGFkdmFuY2VWYWx1ZSA9IENhbGN1bGF0ZUNvbnRyYWN0VmFsdWUoYWR2YW5jZS5Wb2wsIGFkdmFuY2UuQW1vdW50IC8gYWR2YW5jZS5Wb2wsIGNvbnRyYWN0SW5mby5Db250cmFjdClcbiAgICB9XG4gICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICBob2xkVmFsdWUgPSBDYWxjdWxhdGVDb250cmFjdFZhbHVlKHBvc2l0aW9uLkhvbGRWb2wsIHBvc2l0aW9uLkhvbGRBdmdQcmljZSwgY29udHJhY3RJbmZvLkNvbnRyYWN0KVxuICAgIH1cbiAgICBsZXQgdXAgPSBNYXRoLmZsb29yKHByaWNlICogKChJTVJUIC8gY29udHJhY3RJbmZvLlJpc2tMaW1pdC5Jbml0aWFsTWFyZ2luIC0gMikgKiBjb250cmFjdEluZm8uUmlza0xpbWl0LlN0ZXAgKyBjb250cmFjdEluZm8uUmlza0xpbWl0LkJhc2VMaW1pdCAtIGFkdmFuY2VWYWx1ZSAtIGhvbGRWYWx1ZSkgLyBjb250cmFjdEluZm8uQ29udHJhY3QuY29udHJhY3RTaXplKVxuICAgIG1heCA9IElNUlQgPD0gMSAvIGxldmVyYWdlID8gbWF4IDogTWF0aC5tYXgobWF4LCB1cClcbiAgfVxuICByZXR1cm4gbWF4XG59XG5leHBvcnQgeyBDYWxjdWxhdGVWb2x1bWUgfVxuIiwiaW1wb3J0IHsgSXNSZXZlcnNlIH0gZnJvbSAnLi9jb21tb24nXG4vLyBDYWxjdWxhdGVDbG9zZUxvbmdQcm9maXRBbW91bnQg6K6h566X5aSa5LuT5L2N55qE5pyq5a6e546w55uI5LqPXG4vLyB2b2w65oyB5LuT6YePXG4vLyBvcGVuUHJpY2U65oyB5LuT5Z2H5Lu3XG4vLyBjbG9zZVByaWNlOuW9k+WJjeagh+iusOS7t1xuLy8gY29udHJhY3RTaXplOuWQiOe6puWkp+Wwj1xuLy8gaXNSZXZlcnNlOuaYr+WQpuaYr+WPjeWQkeWQiOe6plxuZnVuY3Rpb24gQ2FsY3VsYXRlQ2xvc2VMb25nUHJvZml0QW1vdW50KHZvbCwgb3BlblByaWNlLCBjbG9zZVByaWNlLCBjb250cmFjdCkge1xuICBpZiAodm9sIDw9IDAgfHwgY29udHJhY3QuY29udHJhY3RTaXplIDw9IDAgfHwgb3BlblByaWNlIDw9IDAgfHwgY2xvc2VQcmljZSA8PSAwKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICAvLyBsZXQgb3BlblZhbHVlLCBjbG9zZVZhbHVlXG4gIGlmIChJc1JldmVyc2UoY29udHJhY3QucXVvdGVDb2luLCBjb250cmFjdC5wcmljZUNvaW4pKSB7XG4gICAgLy8gb3BlblZhbHVlID0gdm9sICogY29udHJhY3QuY29udHJhY3RTaXplIC8gb3BlblByaWNlXG4gICAgLy8gY2xvc2VWYWx1ZSA9IHZvbCAqIGNvbnRyYWN0LmNvbnRyYWN0U2l6ZSAvIGNsb3NlUHJpY2VcbiAgICByZXR1cm4gdm9sICogY29udHJhY3QuY29udHJhY3RTaXplICogKDEgLyBvcGVuUHJpY2UgLSAxIC8gY2xvc2VQcmljZSkgLy8gb3BlblZhbHVlIC0gY2xvc2VWYWx1ZVxuICB9XG4gIC8vIG9wZW5WYWx1ZSA9IHZvbCAqIGNvbnRyYWN0LmNvbnRyYWN0U2l6ZSAqIG9wZW5QcmljZVxuICAvLyBjbG9zZVZhbHVlID0gdm9sICogY29udHJhY3QuY29udHJhY3RTaXplICogY2xvc2VQcmljZVxuICByZXR1cm4gdm9sICogY29udHJhY3QuY29udHJhY3RTaXplICogKGNsb3NlUHJpY2UgLSBvcGVuUHJpY2UpIC8vIGNsb3NlVmFsdWUgLSBvcGVuVmFsdWVcbn1cbi8vIENhbGN1bGF0ZUNsb3NlU2hvcnRQcm9maXRBbW91bnQg6K6h566X56m65LuT5L2N55qE5pyq5a6e546w55uI5LqPXG4vLyB2b2w65oyB5LuT6YePXG4vLyBvcGVuUHJpY2U65oyB5LuT5Z2H5Lu3XG4vLyBjbG9zZVByaWNlOuW9k+WJjeagh+iusOS7t1xuLy8gY29udHJhY3RTaXplOuWQiOe6puWkp+Wwj1xuLy8gaXNSZXZlcnNlOuaYr+WQpuaYr+aYr+aWueWQkeWQiOe6plxuLy8gbGV0IG9wZW5WYWx1ZSwgY2xvc2VWYWx1ZVxuZnVuY3Rpb24gQ2FsY3VsYXRlQ2xvc2VTaG9ydFByb2ZpdEFtb3VudCh2b2wsIG9wZW5QcmljZSwgY2xvc2VQcmljZSwgY29udHJhY3QpIHtcbiAgaWYgKHZvbCA8PSAwIHx8IGNvbnRyYWN0LmNvbnRyYWN0U2l6ZSA8PSAwIHx8IG9wZW5QcmljZSA8PSAwIHx8IGNsb3NlUHJpY2UgPD0gMCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKElzUmV2ZXJzZShjb250cmFjdC5xdW90ZUNvaW4sIGNvbnRyYWN0LnByaWNlQ29pbikpIHtcbiAgICAvLyBvcGVuVmFsdWUgPSB2b2wgKiBjb250cmFjdC5jb250cmFjdFNpemUgLyBvcGVuUHJpY2VcbiAgICAvLyBjbG9zZVZhbHVlID0gdm9sICogY29udHJhY3QuY29udHJhY3RTaXplIC8gY2xvc2VQcmljZVxuICAgIHJldHVybiB2b2wgKiBjb250cmFjdC5jb250cmFjdFNpemUgKiAoMSAvIGNsb3NlUHJpY2UgLSAxIC8gb3BlblByaWNlKSAvLyBjbG9zZVZhbHVlIC0gb3BlblZhbHVlXG4gIH1cbiAgLy8gb3BlblZhbHVlID0gdm9sICogY29udHJhY3QuY29udHJhY3RTaXplICogb3BlblByaWNlXG4gIC8vIGNsb3NlVmFsdWUgPSB2b2wgKiBjb250cmFjdC5jb250cmFjdFNpemUgKiBjbG9zZVByaWNlXG4gIHJldHVybiB2b2wgKiBjb250cmFjdC5jb250cmFjdFNpemUgKiAob3BlblByaWNlIC0gY2xvc2VQcmljZSkgLy8gb3BlblZhbHVlIC0gY2xvc2VWYWx1ZVxufVxuZnVuY3Rpb24gTG9uZ09yU29ydCh2b2wsIG9wZW5QcmljZSwgY2xvc2VQcmljZSwgY29udHJhY3QsIHdheSkge1xuICByZXR1cm4gd2F5ID8gQ2FsY3VsYXRlQ2xvc2VMb25nUHJvZml0QW1vdW50KHZvbCwgb3BlblByaWNlLCBjbG9zZVByaWNlLCBjb250cmFjdCkgOiBDYWxjdWxhdGVDbG9zZVNob3J0UHJvZml0QW1vdW50KHZvbCwgb3BlblByaWNlLCBjbG9zZVByaWNlLCBjb250cmFjdClcbn1cbmV4cG9ydCBkZWZhdWx0IExvbmdPclNvcnRcbiIsImV4cG9ydCBkZWZhdWx0IHtcbiAgLy8g6I635Y+W5ZCI57qm5L+h5oGvXG4gIGdldENvbnRyYWN0KHByb2R1Y3RJbmZvKSB7XG4gICAgcmV0dXJuIHtjb250cmFjdFNpemU6IE51bWJlcihwcm9kdWN0SW5mby5mYWNlX3ZhbHVlKSwgcXVvdGVDb2luOiBwcm9kdWN0SW5mby5xdW90ZV9jb2luLCBwcmljZUNvaW46IHByb2R1Y3RJbmZvLmlzX3JldmVyc2UgPyBwcm9kdWN0SW5mby5xdW90ZV9jb2luIDogcHJvZHVjdEluZm8uYmFzZV9jb2lufVxuICB9LFxuICAvLyDojrflj5blkIjnuqbns7vmlbBcbiAgZ2V0Umlza0xpbWl0KHJpc2tfbGltaXQpIHtcbiAgICByZXR1cm4ge0Jhc2VMaW1pdDogTnVtYmVyKHJpc2tfbGltaXQucmlza19saW1pdF9iYXNlKSwgU3RlcDogTnVtYmVyKHJpc2tfbGltaXQucmlza19saW1pdF9zdGVwKSwgSW5pdGlhbE1hcmdpbjogTnVtYmVyKHJpc2tfbGltaXQuaW1yKSwgTWFpbnRlbmFuY2VNYXJnaW46IE51bWJlcihyaXNrX2xpbWl0Lm1tcil9XG4gIH1cbn1cbiIsIi8vIOegtOS6p+ebuOWFs+WFrOW8j1xuaW1wb3J0IHsgSXNSZXZlcnNlIH0gZnJvbSAnLi9jb21tb24nXG5pbXBvcnQgeyBDYWxjdWxhdGVDb250cmFjdFZhbHVlIH0gZnJvbSAnLi92YWx1ZSdcbi8vIENhbGN1bGF0ZUJhbmtydXB0Y3lQcmljZSDorqHnrpfnoLTkuqfku7dcbi8vIHBvc2l0aW9uOueUqOaIt+eahOS7k+S9jVxuLy8gYXNzZXRzOueUqOaIt+eahOi1hOS6pyzlpoLmnpzku5PkvY3nmoTlhajku5PmqKHlvI8s6ZyA6KaB5Lyg5YWl55So5oi36LWE5LqnLOWmguaenOaYr+mAkOS7k+aooeW8jyzkuI3pnIDopoHkvKDlhaXnlKjmiLfotYTkuqdcbmZ1bmN0aW9uIENhbGN1bGF0ZUJhbmtydXB0Y3lQcmljZShwb3NpdGlvbiwgYXNzZXRzLCBjb250cmFjdEluZm8sIHdheSkge1xuICBsZXQgSFYsIEhQLCBQViwgSU0sIHJlc1ZhbHVlLCBTLCBULCBNLCBELCBCUFxuICBIViA9IHBvc2l0aW9uLkhvbGRWb2xcbiAgSFAgPSBwb3NpdGlvbi5Ib2xkQXZnUHJpY2VcbiAgUFYgPSBDYWxjdWxhdGVDb250cmFjdFZhbHVlKEhWLCBIUCwgY29udHJhY3RJbmZvLkNvbnRyYWN0KVxuICAvLyDlvZPliY3ku5PkvY3pnIDopoHnmoTnu7TmjIHkv53or4Hph5FcbiAgSU0gPSBwb3NpdGlvbi5JTVxuICBpZiAoYXNzZXRzKSB7XG4gICAgSU0gPSBJTSArIGFzc2V0c1xuICB9XG4gIC8vIFRvRG8g5L+d6K+B6YeR5LiN5aSf5oCO5LmI5YqeXG4gIC8vIGlmIChJTSA8IDApIHtcbiAgLy8gICByZXR1cm4gLTFcbiAgLy8gfVxuICBTID0gY29udHJhY3RJbmZvLkNvbnRyYWN0LmNvbnRyYWN0U2l6ZVxuICBUID0gY29udHJhY3RJbmZvLkZlZUNvbmZpZy5UYWtlckZlZVxuICAvLyBIVjogaG9sZCB2b2x1bWVcbiAgLy8gQlA6IOegtOS6p+S7t1xuICAvLyBTOiDlkIjnuqbku7fmoLxcbiAgLy8gVDogVGFrZUZlZVJhdGlvXG4gIC8vIFRGOiBUYWtlRmVlXG4gIC8vIEhWKkJQKlMqVCA9IFRGXG4gIC8vIOWkmuS7k1xuICAvLyBQVi1JTSA9IHJlc1ZhbHVlXG4gIC8vIChyZXNWYWx1ZS1URikvKEhWKlMpID0gQlBcbiAgLy8gcmVzVmFsdWUvKEhWKlMrSFYqUypUKSA9IEJQXG4gIC8vIOepuuS7k1xuICAvLyBQVitJTSA9IHJlc1ZhbHVlXG4gIC8vIChQVitJTS1URikvKEhWKlMpID0gQlBcbiAgLy8gcmVzVmFsdWUvKEhWKlMrSFYqUypUKSA9IEJQXG4gIC8vIOegtOS6p+aXtueUqOaIt+aMgeS7k+eahOS7t+WAvFxuICAvLyDlvIDlpJrku5Ms56C05Lqn5pe255qE5LuT5L2N5Lu35YC8ID0g546w5Zyo55qE5LuT5L2N5Lu35YC8IC0g5byA5LuT5L+d6K+B6YeRXG4gIC8vIOW8gOepuuS7kyznoLTkuqfml7bnmoTku5PkvY3ku7flgLwgPSDnjrDlnKjnmoTku5PkvY3ku7flgLwgKyDlvIDku5Pkv53or4Hph5FcbiAgbGV0IGlzUiA9IElzUmV2ZXJzZShjb250cmFjdEluZm8uQ29udHJhY3QucXVvdGVDb2luLCBjb250cmFjdEluZm8uQ29udHJhY3QucHJpY2VDb2luKVxuICBpZiAoaXNSKSB7XG4gICAgd2F5ID0gIXdheVxuICB9XG4gIGlmICh3YXkpIHtcbiAgICByZXNWYWx1ZSA9IFBWIC0gSU1cbiAgICAvLyDlpoLmnpzkv53or4Hph5HlpKfkuo7ku5PkvY3nmoTotYTkuqcs6IKv5a6a5rKh5pyJ6L6+5Yiw5by65bmz5L2N572uXG4gICAgaWYgKHJlc1ZhbHVlIDw9IDApIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuICAgIEQgPSBIViAqIFMgKiAoMSAtIFQpXG4gIH0gZWxzZSB7XG4gICAgcmVzVmFsdWUgPSBQViArIElNXG4gICAgRCA9IEhWICogUyAqICgxICsgVClcbiAgfVxuICBNID0gcmVzVmFsdWVcbiAgaWYgKEQgPD0gMCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIEJQID0gTSAvIERcbiAgaWYgKGlzUikge1xuICAgIGlmIChCUCA8PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgQlAgPSAxIC8gQlBcbiAgfVxuICByZXR1cm4gQlBcbn1cbmV4cG9ydCBkZWZhdWx0IENhbGN1bGF0ZUJhbmtydXB0Y3lQcmljZVxuIiwiaW1wb3J0IENhbGN1bGF0ZUJhbmtydXB0Y3lQcmljZSBmcm9tICcuL2JhbmtydXB0J1xuaW1wb3J0IExvbmdPclNvcnQgZnJvbSAnLi9jbG9zZSdcbmltcG9ydCB7IENhbGN1bGF0ZUNvbnRyYWN0VmFsdWUgfSBmcm9tICcuL3ZhbHVlJ1xuLy8gQ2FsY3VsYXRlUG5sIOiuoeeul+S7k+S9jeebiOWIqeaOkuWQjeezu+aVsFxuLy8g5o6S5bqPID0g55uI5Yip55m+5YiG5q+UICog5pyJ5pWI5p2g5p2GICAo5aaC5p6c55uI5YipKVxuLy8gICAgICAgICA9IOebiOWIqeeZvuWIhuavlCAvIOacieaViOadoOadhiAgKOWmguaenOS6j+aNnylcbi8vIOWFtuS4rVxuLy8gICDmnInmlYjmnaDmnYYgPSBhYnMoKOagh+iusOS7t+WAvCkgLyAo5qCH6K6w5Lu35YC8IC0g56C05Lqn5Lu35YC8KSlcbi8vICAg55uI5Yip55m+5YiG5q+UID0gKOagh+iusOS7t+WAvCAtIOW5s+Wdh+W8gOS7k+S7t+WAvCkgLyBhYnMo5bmz5Z2H5byA5LuT5Lu35YC8KVxuLy8gICDmoIforrDku7flgLwgPSDkvY3kuo7moIforrDku7fmoLzml7bnmoTku5PkvY3ku7flgLxcbi8vICAg56C05Lqn5Lu35YC8ID0g5L2N5LqO56C05Lqn5Lu35qC85pe255qE5LuT5L2N5Lu35YC8XG4vLyAgIOW5s+Wdh+W8gOS7k+S7t+WAvCA9IOS9jeS6juW5s+Wdh+W8gOS7k+S7t+agvOaXtueahOS7k+S9jeS7t+WAvFxuXG5mdW5jdGlvbiBDYWxjdWxhdGVQTkwocG9zaXRpb24sIGFzc2V0cywgZmFpclByaWNlLCBjb250cmFjdEluZm8sIHdheSkge1xuICAvLyDnm4jliKnnmb7liIbmr5QgPSAo5qCH6K6w5Lu35YC8IC0g5bmz5Z2H5byA5LuT5Lu35YC8KSAvIGFicyjlubPlnYflvIDku5Pku7flgLwpXG4gIC8vIOebiOWIqeeZvuWIhuavlD0gW0ZQKlZvbCpTIC0gSFAqVm9sKlNdL0hQKlZvbCpTXG4gIC8vIOacieaViOadoOadhiA9IGFic1so5qCH6K6w5Lu35YC8KSAvICjmoIforrDku7flgLwgLSDnoLTkuqfku7flgLwpXVxuICAvLyDmnInmlYjmnaDmnaAgPSBhYnNbRlAqVm9sKlMvKEZQKlZvbCpTIC0gQlAqVm9sKlMpXVxuICAvLyDmjpLluo8gPSBbKEZQKlZvbCpTIC0gSFAqVm9sKlMpL0hQKlZvbCpTXSphYnNbRlAqVm9sKlMvKEZQKlZvbCpTIC0gQlAqVm9sKlMpXVxuICAvLyBQbmwgPSBbKEZQIC0gSFApL0hQXSphYnNbRlAvKEZQIC0gQlApXVxuICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBsZXQgcHJvZml0LCBwb3NpdGlvblZhbHVlLCBlYXJuaW5nc1JhdGlvLCBCUCwgdG1wLCBsZXZlcmFnZVxuICBwcm9maXQgPSBMb25nT3JTb3J0KHBvc2l0aW9uLkhvbGRWb2wsIHBvc2l0aW9uLkhvbGRBdmdQcmljZSwgZmFpclByaWNlLCBjb250cmFjdEluZm8uQ29udHJhY3QsIHdheSlcbiAgcG9zaXRpb25WYWx1ZSA9IENhbGN1bGF0ZUNvbnRyYWN0VmFsdWUocG9zaXRpb24uSG9sZFZvbCwgcG9zaXRpb24uSG9sZEF2Z1ByaWNlLCBjb250cmFjdEluZm8uQ29udHJhY3QpXG4gIGVhcm5pbmdzUmF0aW8gPSBwcm9maXQgLyBwb3NpdGlvblZhbHVlXG4gIEJQID0gQ2FsY3VsYXRlQmFua3J1cHRjeVByaWNlKHBvc2l0aW9uLCBhc3NldHMsIGNvbnRyYWN0SW5mbylcbiAgdG1wID0gZmFpclByaWNlIC0gQlBcbiAgaWYgKHRtcCA9PT0gMCkge1xuICAgIGlmIChwcm9maXQgPiAwKSB7XG4gICAgICByZXR1cm4gMTAwMDAwMDAwXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuICB9XG4gIGxldmVyYWdlID0gTWF0aC5hYnMoZmFpclByaWNlIC8gdG1wKVxuICBpZiAobGV2ZXJhZ2UgPT09IDApIHtcbiAgICBpZiAocHJvZml0ID4gMCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gICAgcmV0dXJuIC0xMDAwMDAwMDBcbiAgfVxuICBpZiAocHJvZml0IDwgMCkge1xuICAgIHJldHVybiBlYXJuaW5nc1JhdGlvIC8gbGV2ZXJhZ2VcbiAgfVxuICByZXR1cm4gZWFybmluZ3NSYXRpbyAqIGxldmVyYWdlXG59XG5cbmZ1bmN0aW9uIENhbGN1bGF0ZVF1YW50aWxlKGksIHNpemUpIHtcbiAgbGV0IGYgPSBNYXRoLmNlaWwoaSAqIDUgLyBzaXplKVxuICBmICo9IDAuMlxuICByZXR1cm4gZiAqIDEwMFxufVxuXG5leHBvcnQge0NhbGN1bGF0ZVBOTCwgQ2FsY3VsYXRlUXVhbnRpbGV9XG4iLCIgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIOW8gOS7k+mqjOivgSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyAxLuWcqOacgOWkp+WSjOacgOWwj+WMuumXtOWGhVxuICAvLyAyLuW/hemhu+Wwj+S6juetieS6juacgOWkp+WPr+W8gFxuICAvLyAzLuWIpOaWreS7t+agvOaYr+S4jeaYr+W8uuW5s+S7t1xuICAvLyBJc0xpcXVpZGF0ZSDmoLnmja7ku7fmoLzlkozlvIDku5PmlrnlkJHliKTmlq3mmK/lkKbkvJrlvLrlubNcbiAgLy8gcG9zaXRpb25UeXBlOuW8gOS7k+aWueWQkVxuICAvLyBwb3NpdGlvbkxpcXVpZGF0ZVByaWNlOuW8uuW5s+S7t1xuICAvLyBmYWlyUHJpY2U65b2T5YmN5ZCI55CG5Lu35qC8XG4gIGltcG9ydCB7IENhbGN1bGF0ZUNvbnRyYWN0VmFsdWUsIENhbGN1bGF0ZVF1b3RlUHJpY2UgfSBmcm9tICcuL3ZhbHVlJ1xuICBpbXBvcnQgeyBDYWxjdWxhdGVNTSwgQ2FsY3VsYXRlSU1SIH0gZnJvbSAnLi9tYXJnaW4nXG4gIGltcG9ydCB7IElzUmV2ZXJzZSB9IGZyb20gJy4vY29tbW9uJ1xuICBmdW5jdGlvbiBJc0xpcXVpZGF0ZShsb25nT3JTb3J0LCBwb3NpdGlvbkxpcXVpZGF0ZVByaWNlLCBmYWlyUHJpY2UpIHtcbiAgICBpZiAocG9zaXRpb25MaXF1aWRhdGVQcmljZSA8IDApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIGlmIChwb3NpdGlvbkxpcXVpZGF0ZVByaWNlID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKGxvbmdPclNvcnQpIHtcbiAgICAgIGlmIChmYWlyUHJpY2UgPD0gcG9zaXRpb25MaXF1aWRhdGVQcmljZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZmFpclByaWNlID49IHBvc2l0aW9uTGlxdWlkYXRlUHJpY2UpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgLy8gQ2FsY3VsYXRlT3JkZXJMaXF1aWRhdGVQcmljZSDorqHnrpforqLljZXnmoTlvLrlubPku7dcbiAgLy8gb3JkZXI66K6i5Y2VXG4gIC8vIGFzc2V0czrnlKjmiLfotYTkuqcs5aaC5p6c5piv5YWo5LuT5qih5byPLOaJjemcgOimgei+k+WFpeeUqOaIt+i1hOS6pyzpgJDku5PmqKHlvI/kuI3pnIDopoFcbiAgLy8gY29udHJhY3RJbmZvOuWQiOe6puS/oeaBr1xuICBmdW5jdGlvbiBDYWxjdWxhdGVPcmRlckxpcXVpZGF0ZVByaWNlKG9yZGVyLCBhc3NldCwgY29udHJhY3RJbmZvLCBsb25nT3JTb3J0KSB7XG4gICAgbGV0IHZhbHVlLCByZXN0TSwgTU0sIElNUiwgbGV2ZXJhZ2VJTVIsIElNXG4gICAgdmFsdWUgPSBDYWxjdWxhdGVDb250cmFjdFZhbHVlKG9yZGVyLlZvbCwgb3JkZXIuUHJpY2UsIGNvbnRyYWN0SW5mby5Db250cmFjdClcbiAgICByZXN0TSA9IDBcbiAgICBNTSA9IENhbGN1bGF0ZU1NKHZhbHVlLCBjb250cmFjdEluZm8uUmlza0xpbWl0KVxuICAgIC8vIOWmguaenOaYr+WFqOS7k+aooeW8j1xuICAgIC8vIOWFqOS7k+aooeW8jyzkuI3ogIPomZHnlKjmiLfovpPlhaXnmoTmnaDmnYblpKflsI9cbiAgICBpZiAob3JkZXIuT3BlblR5cGUpIHtcbiAgICAgIGlmIChhc3NldCkge1xuICAgICAgICByZXN0TSA9IGFzc2V0IC0gTU0gLy8gYXNzZXQuQXZhaWxhYmxlVm9sXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIOWmguaenOaYr+mAkOS7k+aooeW8j1xuICAgICAgSU1SID0gQ2FsY3VsYXRlSU1SKHZhbHVlLCBjb250cmFjdEluZm8uUmlza0xpbWl0KVxuICAgICAgaWYgKG9yZGVyLkxldmVyYWdlID4gMCkge1xuICAgICAgICBsZXZlcmFnZUlNUiA9IDEgLyBvcmRlci5MZXZlcmFnZVxuICAgICAgICBpZiAobGV2ZXJhZ2VJTVIgPiBJTVIpIHtcbiAgICAgICAgICBJTVIgPSBsZXZlcmFnZUlNUlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBJTSA9IHZhbHVlICogSU1SXG4gICAgICByZXN0TSA9IElNIC0gTU1cbiAgICB9XG4gICAgaWYgKHJlc3RNIDwgMCkge1xuICAgICAgLy8g5aaC5p6c6L+U5Zue5bCP5LqO6Zu2LOihqOekuuiuouWNleaXoOaViFxuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIGxldCBpc1IgPSBJc1JldmVyc2UoY29udHJhY3RJbmZvLkNvbnRyYWN0LnF1b3RlQ29pbiwgY29udHJhY3RJbmZvLkNvbnRyYWN0LnByaWNlQ29pbilcbiAgICBpZiAoaXNSKSB7XG4gICAgICBsb25nT3JTb3J0ID0gIWxvbmdPclNvcnRcbiAgICB9XG4gICAgLy8g5aaC5p6c5byA5aSaXG4gICAgaWYgKGxvbmdPclNvcnQpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgLSByZXN0TVxuICAgICAgLy8g55So5oi36LWE5Lqn55qE5Lu35YC85aSn5LqO6K6i5Y2V55qE5Lu35YC8XG4gICAgICAvLyDlj6ropoHlvZPlkIjnuqbku7fmoLzmuIXpm7bml7bmiY3kvJrlvLrlubNcbiAgICAgIGlmICh2YWx1ZSA8PSAwKSB7XG4gICAgICAgIC8vIOi/lOWbnumbtlxuICAgICAgICByZXR1cm4gaXNSID8gMTAwMDAwMDAwIDogMFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlICsgcmVzdE1cbiAgICB9XG4gICAgcmV0dXJuIENhbGN1bGF0ZVF1b3RlUHJpY2UodmFsdWUsIG9yZGVyLlZvbCwgY29udHJhY3RJbmZvLkNvbnRyYWN0KVxuICB9XG4gIC8vIENhbGN1bGF0ZVBvc2l0aW9uTGlxdWlkYXRlUHJpY2Ug6K6h566X5LuT5L2N55qE5by65bmz5Lu3XG4gIC8vIHBvc2l0aW9uOuS7k+S9jVxuICAvLyBhc3NldHM655So5oi36LWE5LqnLOWmguaenOaYr+WFqOS7k+aooeW8jyzmiY3pnIDopoHovpPlhaXnlKjmiLfotYTkuqcs6YCQ5LuT5qih5byP5LiN6ZyA6KaBXG4gIC8vIGNvbnRyYWN0SW5mbzrlkIjnuqbkv6Hmga9cbiAgZnVuY3Rpb24gQ2FsY3VsYXRlUG9zaXRpb25MaXF1aWRhdGVQcmljZShwb3NpdGlvbiwgYXNzZXRzLCBjb250cmFjdEluZm8sIGxvbmdPclNvcnQpIHtcbiAgICBsZXQgSFYsIEhQLCBQViwgcmVzVmFsdWUsIElNLCByZXN0TSwgVCwgRCwgTSwgTFBcbiAgICBIViA9IHBvc2l0aW9uLkhvbGRWb2xcbiAgICBIUCA9IHBvc2l0aW9uLkhvbGRBdmdQcmljZVxuICAgIFBWID0gQ2FsY3VsYXRlQ29udHJhY3RWYWx1ZShIViwgSFAsIGNvbnRyYWN0SW5mby5Db250cmFjdClcbiAgICAvLyDlvZPliY3ku5PkvY3pnIDopoHnmoTnu7TmjIHkv53or4Hph5FcbiAgICBJTSA9IHBvc2l0aW9uLklNXG4gICAgaWYgKGFzc2V0cykge1xuICAgICAgSU0gPSBJTSArIGFzc2V0c1xuICAgIH1cbiAgICByZXN0TSA9IElNIC0gcG9zaXRpb24uTU1cbiAgICAvLyBUb0RvIOS/neivgemHkeS4jeWkn+aAjuS5iOWKnlxuICAgIC8vIGlmIChyZXN0TSA8IDApIHtcbiAgICAvLyAgIHJldHVybiAtMVxuICAgIC8vIH1cbiAgICBsZXQgUyA9IGNvbnRyYWN0SW5mby5Db250cmFjdC5jb250cmFjdFNpemVcbiAgICBUID0gY29udHJhY3RJbmZvLkZlZUNvbmZpZy5UYWtlckZlZVxuICAgIC8vIEhWOiBob2xkIHZvbHVtZVxuICAgIC8vIExQOiDlvLrlubPku7dcbiAgICAvLyBTOiDlkIjnuqbku7fmoLxcbiAgICAvLyBUOiBUYWtlRmVlUmF0aW9cbiAgICAvLyBURjogVGFrZUZlZVxuICAgIC8vIEhWKkxQKlMqVCA9IFRGXG4gICAgLy8g5aSa5LuTXG4gICAgLy8gUFYtKElNLU1NKSA9IHJlc1ZhbHVlXG4gICAgLy8gKHJlc1ZhbHVlK1RGKS8oSFYqUykgPSBMUFxuICAgIC8vIHJlc1ZhbHVlLyhIVipTLUhWKlMqVCkgPSBMUFxuICAgIC8vIOepuuS7k1xuICAgIC8vIFBWKyhJTS1NTSkgPSByZXNWYWx1ZVxuICAgIC8vIChQVisoSU0tTU0pLVRGKS8oSFYqUykgPSBMUFxuICAgIC8vIHJlc1ZhbHVlLyhIVipTK0hWKlMqVCkgPSBMUFxuICAgIEQgPSAwXG4gICAgbGV0IGlzUiA9IElzUmV2ZXJzZShjb250cmFjdEluZm8uQ29udHJhY3QucXVvdGVDb2luLCBjb250cmFjdEluZm8uQ29udHJhY3QucHJpY2VDb2luKVxuICAgIGlmIChpc1IpIHtcbiAgICAgIGxvbmdPclNvcnQgPSAhbG9uZ09yU29ydFxuICAgIH1cbiAgICAvLyDliKTmlq3mmK/lkKbmmK/lvIDlpJpcbiAgICBpZiAobG9uZ09yU29ydCkge1xuICAgICAgcmVzVmFsdWUgPSBQViAtIHJlc3RNXG4gICAgICAvLyDlpoLmnpzkv53or4Hph5HlpKfkuo7ku5PkvY3nmoTotYTkuqcs6IKv5a6a5rKh5pyJ6L6+5Yiw5by65bmz5L2N572uXG4gICAgICBpZiAocmVzVmFsdWUgPD0gMCkge1xuICAgICAgICByZXR1cm4gaXNSID8gMTAwMDAwMDAwIDogMFxuICAgICAgfVxuICAgICAgRCA9IEhWICogUyAqICgxIC0gVClcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzVmFsdWUgPSBQViArIHJlc3RNXG4gICAgICBEID0gSFYgKiBTICogKDEgKyBUKVxuICAgIH1cbiAgICBNID0gcmVzVmFsdWVcbiAgICBpZiAoRCA8PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgTFAgPSBNIC8gRFxuICAgIGlmIChpc1IpIHtcbiAgICAgIExQID0gMSAvIExQXG4gICAgfVxuICAgIGlmIChMUCA+IDEwMDAwMDAwMCkge1xuICAgICAgTFAgPSAxMDAwMDAwMDBcbiAgICB9XG4gICAgcmV0dXJuIExQXG4gIH1cbiAgZXhwb3J0IHtJc0xpcXVpZGF0ZSwgQ2FsY3VsYXRlT3JkZXJMaXF1aWRhdGVQcmljZSwgQ2FsY3VsYXRlUG9zaXRpb25MaXF1aWRhdGVQcmljZX1cbiIsImltcG9ydCB7IENhbGN1bGF0ZUNvbnRyYWN0VmFsdWUsIENhbGN1bGF0ZUNvbnRyYWN0QmFzaWNWYWx1ZSwgQ2FsY3VsYXRlQ29udHJhY3RCYXNpY1ZhbHVlVHdvLCBDYWxjdWxhdGVRdW90ZVByaWNlIH0gZnJvbSAnLi92YWx1ZSdcbmltcG9ydCBDYWxjdWxhdGVBZHZhbmNlT3BlbkNvc3QgZnJvbSAnLi9vcGVuJ1xuaW1wb3J0IHsgTWFyZ2luQ29pbiwgSXNSZXZlcnNlIH0gZnJvbSAnLi9jb21tb24nXG5pbXBvcnQgeyBDYWxjdWxhdGVWb2x1bWUgfSBmcm9tICcuL3ZvbHVtZSdcbmltcG9ydCBMb25nT3JTb3J0IGZyb20gJy4vY2xvc2UnXG5pbXBvcnQgY29udHJhY3RPYmogZnJvbSAnLi9jb250cmFjdE9iaidcbmltcG9ydCB7IENhbGN1bGF0ZVBOTCwgQ2FsY3VsYXRlUXVhbnRpbGUgfSBmcm9tICcuL2FkbCdcbmltcG9ydCB7IENhbGN1bGF0ZU9yZGVyTGlxdWlkYXRlUHJpY2UsIENhbGN1bGF0ZVBvc2l0aW9uTGlxdWlkYXRlUHJpY2UsIElzTGlxdWlkYXRlIH0gZnJvbSAnLi9saXF1aWRhdGUnXG5leHBvcnQgZGVmYXVsdCB7IENhbGN1bGF0ZUNvbnRyYWN0VmFsdWUsIENhbGN1bGF0ZUFkdmFuY2VPcGVuQ29zdCwgQ2FsY3VsYXRlQ29udHJhY3RCYXNpY1ZhbHVlLCBNYXJnaW5Db2luLCBDYWxjdWxhdGVWb2x1bWUsIExvbmdPclNvcnQsIGNvbnRyYWN0T2JqLCBDYWxjdWxhdGVQTkwsIENhbGN1bGF0ZVF1YW50aWxlLCBDYWxjdWxhdGVPcmRlckxpcXVpZGF0ZVByaWNlLCBJc0xpcXVpZGF0ZSwgQ2FsY3VsYXRlUG9zaXRpb25MaXF1aWRhdGVQcmljZSwgSXNSZXZlcnNlLCBDYWxjdWxhdGVDb250cmFjdEJhc2ljVmFsdWVUd28sIENhbGN1bGF0ZVF1b3RlUHJpY2UgfVxuIiwiaW1wb3J0ICcuL2Nzcy9pbmRleC5zY3NzJztcclxuXHJcbmltcG9ydCBVdGlscyBmcm9tICcuL2pzL3V0aWwuanMnO1xyXG5pbXBvcnQgRm9ybXVsYSBmcm9tICcuL2pzL2Zvcm11bGEvaW5kZXguanMnO1xyXG5cclxubmV3IFZ1ZSh7XHJcbiAgZWw6ICcjYXBwJyxcclxuICBmaWx0ZXJzOiB7XHJcbiAgICBhZGRDb21tb206IFV0aWxzLmFkZENvbW1vbVxyXG4gIH0sXHJcbiAgZGF0YSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIC8vIOiuoeeul+aWueahiCAx77yaIOebiOS6j+iuoeeulyAgMi4g5by65bmz5Lu35qC8IDMu55uu5qCH5Lu35pS255uK546HXHJcbiAgICAgIGNhbGN1bGF0b3JUeXBlOiAxLFxyXG4gICAgICAvLyDmnaDmnYbliJfooajvvIzmlbDmja7pnIDku47mlbDmja7lupPojrflj5ZcclxuICAgICAgbGV2ZXJhZ2VMaXN0OiBbXHJcbiAgICAgICAge1wibmFtZVwiOiBcImFsbENhYmluXCIsIFwidmFsdWVcIjogMTAwfSxcclxuICAgICAgICB7XCJuYW1lXCI6IFwiMTAweFwiLCBcInZhbHVlXCI6IDEwMH0sXHJcbiAgICAgICAge1wibmFtZVwiOiBcIjUweFwiLCBcInZhbHVlXCI6IDUwfSxcclxuICAgICAgICB7XCJuYW1lXCI6IFwiMjB4XCIsIFwidmFsdWVcIjogMjB9LFxyXG4gICAgICAgIHtcIm5hbWVcIjogXCIxMHhcIiwgXCJ2YWx1ZVwiOiAxMH1cclxuICAgICAgXSxcclxuICAgICAgZm9ybToge1xyXG4gICAgICAgIC8vIOadoOadhlxyXG4gICAgICAgIGxldmVyYWdlSW5mbzoge1xyXG4gICAgICAgICAgdmFsdWU6ICcnXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyDorqHnrpfnsbvlnovvvIwx77ya55uu5qCH5pS255uK6aKd77yMMu+8muebruagh+aUtuebiueOh1xyXG4gICAgICAgIHRhcmdldEVhcm5pbmdzOiAxLFxyXG4gICAgICAgIGNhbGN1bGF0b3JUeXBlOiAxLCAvLyDorqHnrpfnsbvlnotcclxuICAgICAgICBvcHRpb25zOiAxLCAvLyDmlrnlkJFcclxuICAgICAgICBwb3NpdGlvbnM6ICcnLCAvLyDku5PkvY1cclxuICAgICAgICBvcGVuUHJpY2U6ICcnLCAvLyDlvIDku5Pku7fmoLxcclxuICAgICAgICBjbG9zZVByaWNlOiAnJywgLy8g5bmz5LuT5Lu35qC8XHJcbiAgICAgICAgZWFybmluZ3M6ICcnLCAvLyDmlLbnm4rpop3miJbogIXmlLbnm4rnjodcclxuICAgICAgfSxcclxuICAgICAgLy8g55uI5LqP6K6h566XXHJcbiAgICAgIHByb2ZpdEFuZExvc3M6IHtcclxuICAgICAgICBpbTogMCwgLy8g5Y2g55So5L+d6K+B6YeRXHJcbiAgICAgICAgdmFsdWU6IDAsIC8vIOS7k+S9jeS7t+WAvFxyXG4gICAgICAgIHBsOiAwLCAvLyDnm4jkuo9cclxuICAgICAgICByYXRlOiAwIC8vIOaUtuebiueOh1xyXG4gICAgICB9LFxyXG4gICAgICAvLyDlvLrlubPku7fmoLxcclxuICAgICAgZmxhdFByaWNlOiB7XHJcbiAgICAgICAgZmxhdFByaWNlOiAwLCAvLyDlvLrlubPku7fmoLxcclxuICAgICAgICB2YWx1ZTogMCwgLy8g5LuT5L2N5Lu35YC8XHJcbiAgICAgICAgaW06IDAsIC8vIOWunumZhei1t+Wni+S/neivgemHkeeOh1xyXG4gICAgICAgIG1tOiAwICAgLy8g5a6e6ZmF57u05oyB5L+d6K+B6YeR546HXHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIOebruagh+S7t+aUtuebiueOh1xyXG4gICAgICB0YXJnZXRDbG9zZToge1xyXG4gICAgICAgIHByaWNlOiAwLFxyXG4gICAgICAgIGltOiAwLFxyXG4gICAgICAgIHZhbHVlT3JSb3RlOiAwXHJcbiAgICAgIH0sXHJcbiAgICAgIC8vIOmcgOS7juWQjuWPsOiOt+WPluaVsOaNrlxyXG4gICAgICBwcm9kdWN0SW5mbzoge1xyXG4gICAgICAgIC8vXCJpbnN0cnVtZW50X2lkXCI6IDEsXHJcbiAgICAgICAgLy9cImluZGV4X2lkXCI6IDEsXHJcbiAgICAgICAgXCJzeW1ib2xcIjogXCJCVENVU0RUXCIsXHJcbiAgICAgICAgLy9cIm5hbWVfemhcIjogXCJCVENVU0RU5rC457ut5ZCI57qmXCIsXHJcbiAgICAgICAgLy9cIm5hbWVfZW5cIjogXCJCVENVU0RUIFNXQVBcIixcclxuICAgICAgICBcImJhc2VfY29pblwiOiBcIkJUQ1wiLFxyXG4gICAgICAgIFwicXVvdGVfY29pblwiOiBcIlVTRFRcIixcclxuICAgICAgICAvL1wibWFyZ2luX2NvaW5cIjogXCJVU0RUXCIsXHJcbiAgICAgICAgXCJpc19yZXZlcnNlXCI6IGZhbHNlLFxyXG4gICAgICAgIFwibWFya2V0X25hbWVcIjogXCIqXCIsXHJcbiAgICAgICAgXCJmYWNlX3ZhbHVlXCI6IFwiMC4wMDAxXCIsXHJcbiAgICAgICAgLy9cImJlZ2luX2F0XCI6IFwiMjAxOS0xMC0yOVQwMDowMDowMFpcIixcclxuICAgICAgICAvL1wic2V0dGxlX2F0XCI6IFwiMjAyMC0wMy0wMVQxNjowMDowMFpcIixcclxuICAgICAgICAvL1wic2V0dGxlbWVudF9pbnRlcnZhbFwiOiAyODgwMCxcclxuICAgICAgICAvL1wibWluX2xldmVyYWdlXCI6IFwiMVwiLFxyXG4gICAgICAgIC8vXCJtYXhfbGV2ZXJhZ2VcIjogXCIxMDBcIixcclxuICAgICAgICAvL1wicHhfdW5pdFwiOiBcIjAuMDFcIixcclxuICAgICAgICAvL1wicXR5X3VuaXRcIjogXCIxXCIsXHJcbiAgICAgICAgLy9cInZhbHVlX3VuaXRcIjogXCIwLjAwMDFcIixcclxuICAgICAgICAvL1wibWluX3F0eVwiOiBcIjFcIixcclxuICAgICAgICAvL1wibWF4X3F0eVwiOiBcIjEwMDAwMDAwMFwiLFxyXG4gICAgICAgIC8vXCJwb3NpdGlvbl90eXBlXCI6IDMsXHJcbiAgICAgICAgLy9cInVuZGVyd2VpZ2h0X3R5cGVcIjogMSxcclxuICAgICAgICAvL1wic3RhdHVzXCI6IDMsXHJcbiAgICAgICAgLy9cImFyZWFcIjogMSxcclxuICAgICAgICAvL1wiY3JlYXRlZF9hdFwiOiBcIjIwMTktMTEtMTlUMTA6NDE6MzguMDU5NDU2WlwiLFxyXG4gICAgICAgIC8vXCJkZXB0aF9yb3VuZFwiOiBcIjEuMDFcIixcclxuICAgICAgICAvL1wibWF4X2Z1bmRpbmdfcmF0ZVwiOiBcIjAuMDAzNzVcIixcclxuICAgICAgICAvL1wibWluX2Z1bmRpbmdfcmF0ZVwiOiBcIi0wLjAwMzc1XCIsXHJcbiAgICAgICAgXCJyaXNrX2xpbWl0X2Jhc2VcIjogXCIxMDAwMDAwXCIsXHJcbiAgICAgICAgXCJyaXNrX2xpbWl0X3N0ZXBcIjogXCI1MDAwMDBcIixcclxuICAgICAgICBcIm1tclwiOiBcIjAuMDA1XCIsXHJcbiAgICAgICAgXCJpbXJcIjogXCIwLjAxXCIsXHJcbiAgICAgICAgLy9cIm1ha2VyX2ZlZV9yYXRpb1wiOiBcIjAuMDAwMjVcIixcclxuICAgICAgICAvL1widGFrZXJfZmVlX3JhdGlvXCI6IFwiMC4wMDA3NVwiLFxyXG4gICAgICAgIC8vXCJzZXR0bGVfZmVlX3JhdGlvXCI6IFwiMFwiLFxyXG4gICAgICAgIC8vXCJwbGFuX29yZGVyX3ByaWNlX21pbl9zY29wZVwiOiBcIjAuMDAxXCIsXHJcbiAgICAgICAgLy9cInBsYW5fb3JkZXJfcHJpY2VfbWF4X3Njb3BlXCI6IFwiMlwiLFxyXG4gICAgICAgIC8vXCJwbGFuX29yZGVyX21heF9jb3VudFwiOiAxMCxcclxuICAgICAgICAvL1wicGxhbl9vcmRlcl9taW5fbGlmZV9jeWNsZVwiOiAyNCxcclxuICAgICAgICAvL1wicGxhbl9vcmRlcl9tYXhfbGlmZV9jeWNsZVwiOiAxNjgsXHJcbiAgICAgICAgXCJwcmljZV9jb2luXCI6IFwiQlRDXCJcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LFxyXG4gIGNvbXB1dGVkOiB7XHJcbiAgICAvLyDlhazlhbHmlbDmja7vvIzpnIDku47lkI7lj7Dojrflj5ZcclxuICAgIGNvbW1vbigpIHtcclxuICAgICAgbGV0IG9iaiA9IHtcclxuICAgICAgICBcInB4VW5pdFwiOiAyLFxyXG4gICAgICAgIC8vXCJxdHlVbml0XCI6IDEsXHJcbiAgICAgICAgXCJ2YWx1ZVVuaXRcIjogNCxcclxuICAgICAgICBcIm1hcmdpblVuaXRcIjogXCJVU0RUXCIsXHJcbiAgICAgICAgLy9cImhhdmVBc3NlcnRcIjogMCxcclxuICAgICAgICAvL1wicG9zaXRpb25Mb3NzXCI6IDAsXHJcbiAgICAgICAgLy9cInNob3dPcGVuQWNjb3VudFwiOiBmYWxzZSxcclxuICAgICAgICBcIlBOTFwiOiAwLFxyXG4gICAgICAgIC8vXCJsaXF1aWRhdGVBc3NlcnRMb25nXCI6IDAsXHJcbiAgICAgICAgLy9cImxpcXVpZGF0ZUFzc2VydFNvcnRcIjogMCxcclxuICAgICAgICAvL1wiaW1Ub3RhbFwiOiAwLFxyXG4gICAgICAgIC8qXCJsZXZlcmFnZUxpc3RcIjogW1xyXG4gICAgICAgICAge1wibmFtZVwiOiBcImFsbENhYmluXCIsIFwidmFsdWVcIjogMTAwfSxcclxuICAgICAgICAgIHtcIm5hbWVcIjogXCIxMDB4XCIsIFwidmFsdWVcIjogMTAwfSxcclxuICAgICAgICAgIHtcIm5hbWVcIjogXCI1MHhcIixcInZhbHVlXCI6IDUwfSxcclxuICAgICAgICAgIHtcIm5hbWVcIjogXCIyMHhcIiwgXCJ2YWx1ZVwiOiAyMH0sXHJcbiAgICAgICAgICB7XCJuYW1lXCI6IFwiMTB4XCIsIFwidmFsdWVcIjogMTB9XHJcbiAgICAgICAgXSwqL1xyXG4gICAgICAgIC8vXCJpc1BsYW5cIjogZmFsc2UsXHJcbiAgICAgICAgLy9cImxpbWl0VHlwZVwiOiAxXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9LFxyXG4gIH0sXHJcbiAgbWV0aG9kczoge1xyXG4gICAgY2FsY3VsYXRvcigpIHtcclxuICAgICAgbGV0IGZvcm0gPSB0aGlzLmZvcm07XHJcbiAgICAgIGxldCBwcm9maXRBbmRMb3NzID0gdGhpcy5wcm9maXRBbmRMb3NzO1xyXG4gICAgICBzd2l0Y2ggKHRoaXMuY2FsY3VsYXRvclR5cGUpIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICBpZiAoIWZvcm0ucG9zaXRpb25zIHx8ICFmb3JtLm9wZW5QcmljZSB8fCAhZm9ybS5jbG9zZVByaWNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJG5vdGlmeS53YXJuaW5nKHtcclxuICAgICAgICAgICAgICB0aXRsZTogJ+aPkOekuicsXHJcbiAgICAgICAgICAgICAgbWVzc2FnZTogJ+e8uuWwkeW/heimgeWPguaVsO+8jOivt+ihpeWFheWujOaVtOWPguaVsCdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIC8vIOS7k+S9jeS7t+WAvFxyXG4gICAgICAgICAgdGhpcy5wcm9maXRBbmRMb3NzLnZhbHVlID0gdGhpcy5DYWxjdWxhdGVDb250cmFjdFZhbHVlKE51bWJlcihmb3JtLnBvc2l0aW9ucyksIE51bWJlcihmb3JtLm9wZW5QcmljZSkpO1xyXG4gICAgICAgICAgbGV0IG1hcmdpbiA9IHRoaXMubWFyZ2luUmF0ZSh0aGlzLnByb2ZpdEFuZExvc3MudmFsdWUpO1xyXG4gICAgICAgICAgLy8g5Y2g55So5L+d6K+B6YeRXHJcbiAgICAgICAgICB0aGlzLnByb2ZpdEFuZExvc3MuaW0gPSBwcm9maXRBbmRMb3NzLnZhbHVlICogTWF0aC5tYXgobWFyZ2luLmluaXRpYWwsIDEgLyBmb3JtLmxldmVyYWdlSW5mby52YWx1ZSk7XHJcbiAgICAgICAgICAvLyDnm4jkuo9cclxuICAgICAgICAgIHRoaXMucHJvZml0QW5kTG9zcy5wbCA9IHRoaXMucGxGbihmb3JtLm9wZW5QcmljZSwgZm9ybS5jbG9zZVByaWNlLCBOdW1iZXIoZm9ybS5wb3NpdGlvbnMpLCBmb3JtLm9wdGlvbnMgPT09IDEpO1xyXG4gICAgICAgICAgLy8g5pS255uK546HXHJcbiAgICAgICAgICB0aGlzLnByb2ZpdEFuZExvc3MucmF0ZSA9IHByb2ZpdEFuZExvc3MucGwgLyBwcm9maXRBbmRMb3NzLmltICogMTAwO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgaWYgKCFmb3JtLnBvc2l0aW9ucyB8fCAhZm9ybS5vcGVuUHJpY2UpIHtcclxuICAgICAgICAgICAgdGhpcy4kbm90aWZ5Lndhcm5pbmcoe1xyXG4gICAgICAgICAgICAgIHRpdGxlOiAn5o+Q56S6JyxcclxuICAgICAgICAgICAgICBtZXNzYWdlOiAn57y65bCR5b+F6KaB5Y+C5pWw77yM6K+36KGl5YWF5a6M5pW05Y+C5pWwJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgdGhpcy5mbGF0UHJpY2UudmFsdWUgPSB0aGlzLkNhbGN1bGF0ZUNvbnRyYWN0VmFsdWUoTnVtYmVyKGZvcm0ucG9zaXRpb25zKSwgTnVtYmVyKGZvcm0ub3BlblByaWNlKSk7XHJcbiAgICAgICAgICBsZXQgbWFyZ2luMSA9IHRoaXMubWFyZ2luUmF0ZSh0aGlzLmZsYXRQcmljZS52YWx1ZSk7XHJcbiAgICAgICAgICB0aGlzLmZsYXRQcmljZS5pbSA9IE1hdGgubWF4KG1hcmdpbjEuaW5pdGlhbCwgMSAvIGZvcm0ubGV2ZXJhZ2VJbmZvLnZhbHVlKTtcclxuICAgICAgICAgIHRoaXMuZmxhdFByaWNlLm1tID0gbWFyZ2luMS5tYWludGVuYW5jZTtcclxuICAgICAgICAgIC8vIGxldCBmZWUgPSBOdW1iZXIodGhpcy5wcm9kdWN0SW5mby50YWtlcl9mZWVfcmF0aW8pXHJcbiAgICAgICAgICAvLyBsZXQgcG9zaXRpb24gPSB7SG9sZFZvbDogTnVtYmVyKHRoaXMucG9zaXRpb25zKSwgSG9sZEF2Z1ByaWNlOiBOdW1iZXIodGhpcy5vcGVuUHJpY2UpLCBJTTogdGhpcy5mbGF0UHJpY2UuaW0sIE1NOiB0aGlzLmZsYXRQcmljZS5tbX1cclxuICAgICAgICAgIC8vIHRoaXMuZmxhdFByaWNlLmZsYXRQcmljZSA9IEZvcm11bGEuQ2FsY3VsYXRlUG9zaXRpb25MaXF1aWRhdGVQcmljZShwb3NpdGlvbiwgMCwgdGhpcy5nZXRDb250cmFjdEluZm8oKSwgIXRoaXMub3B0aW9ucylcclxuICAgICAgICAgIC8vIGxldCBwbCA9IHRoaXMuZmxhdFByaWNlLnZhbHVlICogKG1hcmdpbi5pbml0aWFsIC0gbWFyZ2luLm1haW50ZW5hbmNlKSAqICh0aGlzLm9wdGlvbnMgPyAxICsgZmVlIDogMSAtIGZlZSlcclxuICAgICAgICAgIHRoaXMuZmxhdFByaWNlLmZsYXRQcmljZSA9IHRoaXMubGlxdWlkYXRlUHJpY2UoTnVtYmVyKGZvcm0ucG9zaXRpb25zKSwgTnVtYmVyKGZvcm0ub3BlblByaWNlKSwgZm9ybS5sZXZlcmFnZUluZm8udmFsdWUpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgaWYgKCFmb3JtLnBvc2l0aW9ucyB8fCAhZm9ybS5vcGVuUHJpY2UgfHwgIWZvcm0uZWFybmluZ3MpIHtcclxuICAgICAgICAgICAgdGhpcy4kbm90aWZ5Lndhcm5pbmcoe1xyXG4gICAgICAgICAgICAgIHRpdGxlOiAn5o+Q56S6JyxcclxuICAgICAgICAgICAgICBtZXNzYWdlOiAn57y65bCR5b+F6KaB5Y+C5pWw77yM6K+36KGl5YWF5a6M5pW05Y+C5pWwJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGV0IHZhbHVlID0gdGhpcy5DYWxjdWxhdGVDb250cmFjdFZhbHVlKE51bWJlcihmb3JtLnBvc2l0aW9ucyksIE51bWJlcihmb3JtLm9wZW5QcmljZSkpO1xyXG4gICAgICAgICAgbGV0IG1hcmdpbjIgPSB0aGlzLm1hcmdpblJhdGUodmFsdWUpO1xyXG4gICAgICAgICAgdGhpcy50YXJnZXRDbG9zZS5pbSA9IHZhbHVlICogTWF0aC5tYXgobWFyZ2luMi5pbml0aWFsLCAxIC8gZm9ybS5sZXZlcmFnZUluZm8udmFsdWUpO1xyXG4gICAgICAgICAgbGV0IGlzUiA9IEZvcm11bGEuSXNSZXZlcnNlKHRoaXMucHJvZHVjdEluZm8ucXVvdGVfY29pbiwgdGhpcy5wcm9kdWN0SW5mby5wcmljZV9jb2luKTtcclxuICAgICAgICAgIGxldCBvcHRpb25zVHJ1ZSA9IGZvcm0ub3B0aW9ucyA9PT0gMTtcclxuICAgICAgICAgIGlmIChmb3JtLnRhcmdldEVhcm5pbmdzID09PSAxKSB7XHJcbiAgICAgICAgICAgIGlmICgob3B0aW9uc1RydWUgJiYgIWlzUikgfHwgKCFvcHRpb25zVHJ1ZSAmJiBpc1IpKSB7XHJcbiAgICAgICAgICAgICAgdmFsdWUgKz0gTnVtYmVyKGZvcm0uZWFybmluZ3MpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHZhbHVlIC09IE51bWJlcihmb3JtLmVhcm5pbmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnRhcmdldENsb3NlLnZhbHVlT3JSb3RlID0gZm9ybS5lYXJuaW5ncyAvIHRoaXMudGFyZ2V0Q2xvc2UuaW07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRhcmdldENsb3NlLnZhbHVlT3JSb3RlID0gZm9ybS5lYXJuaW5ncyAqIHRoaXMudGFyZ2V0Q2xvc2UuaW0gLyAxMDA7XHJcbiAgICAgICAgICAgIGlmICgob3B0aW9uc1RydWUgJiYgIWlzUikgfHwgKCFvcHRpb25zVHJ1ZSAmJiBpc1IpKSB7XHJcbiAgICAgICAgICAgICAgdmFsdWUgKz0gdGhpcy50YXJnZXRDbG9zZS52YWx1ZU9yUm90ZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB2YWx1ZSAtPSB0aGlzLnRhcmdldENsb3NlLnZhbHVlT3JSb3RlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICB0aGlzLnRhcmdldENsb3NlLnByaWNlID0gdGhpcy50YXJnZXRDbG9zZVByaWNlRm4odmFsdWUsIE51bWJlcihmb3JtLnBvc2l0aW9ucykpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICAvLyDojrflj5blkIjnuqblr7nosaFcclxuICAgIGdldENvbnRyYWN0SW5mbygpIHtcclxuICAgICAgbGV0ICBwcm9kdWN0SW5mbyA9IHRoaXMucHJvZHVjdEluZm87XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgRmVlQ29uZmlnOiB7VGFrZXJGZWU6IE51bWJlcihwcm9kdWN0SW5mby50YWtlcl9mZWVfcmF0aW8pfSxcclxuICAgICAgICBDb250cmFjdDogRm9ybXVsYS5jb250cmFjdE9iai5nZXRDb250cmFjdChwcm9kdWN0SW5mbyksXHJcbiAgICAgICAgUmlza0xpbWl0OiBGb3JtdWxhLmNvbnRyYWN0T2JqLmdldFJpc2tMaW1pdChwcm9kdWN0SW5mbylcclxuICAgICAgfTtcclxuICAgIH0sXHJcbiAgICAvLyDnrpfku5PkvY3ku7flgLxcclxuICAgIENhbGN1bGF0ZUNvbnRyYWN0VmFsdWUodm9sLCBwcmljZSkge1xyXG4gICAgICByZXR1cm4gRm9ybXVsYS5DYWxjdWxhdGVDb250cmFjdFZhbHVlKHZvbCwgcHJpY2UsIEZvcm11bGEuY29udHJhY3RPYmouZ2V0Q29udHJhY3QodGhpcy5wcm9kdWN0SW5mbykpXHJcbiAgICB9LFxyXG4gICAgLy8g55uI5LqP6K6h566XXHJcbiAgICBwbEZuKG9wZW4sIGNsb3NlLCBwb3NpdGlvbnMsIHdheSkge1xyXG4gICAgICByZXR1cm4gRm9ybXVsYS5Mb25nT3JTb3J0KHBvc2l0aW9ucywgb3BlbiwgY2xvc2UsIEZvcm11bGEuY29udHJhY3RPYmouZ2V0Q29udHJhY3QodGhpcy5wcm9kdWN0SW5mbyksIHdheSkgfHwgMFxyXG4gICAgfSxcclxuICAgIC8vIOiuoeeul+ebruagh+W5s+S7k+S7t+agvFxyXG4gICAgdGFyZ2V0Q2xvc2VQcmljZUZuKHZhbHVlLCB2b2wpIHtcclxuICAgICAgcmV0dXJuIEZvcm11bGEuQ2FsY3VsYXRlUXVvdGVQcmljZSh2YWx1ZSwgdm9sLCBGb3JtdWxhLmNvbnRyYWN0T2JqLmdldENvbnRyYWN0KHRoaXMucHJvZHVjdEluZm8pKVxyXG4gICAgfSxcclxuICAgIC8vIOiuoeeul+ebruagh+W5s+S7k+S7t+agvFxyXG4gICAgbGlxdWlkYXRlUHJpY2UoVm9sLCBQcmljZSwgTGV2ZXJhZ2UpIHtcclxuICAgICAgbGV0IG9wdGlvbnNUcnVlID0gdGhpcy5mb3JtLm9wdGlvbnMgPT09IDE7XHJcbiAgICAgIHJldHVybiBGb3JtdWxhLkNhbGN1bGF0ZU9yZGVyTGlxdWlkYXRlUHJpY2Uoe1ZvbCwgUHJpY2UsIExldmVyYWdlfSwgMCwgdGhpcy5nZXRDb250cmFjdEluZm8oKSwgb3B0aW9uc1RydWUpO1xyXG4gICAgfSxcclxuICAgIC8vIOiuoeeul+i1t+Wni+WSjOe7tOaMgeS/neivgemHkeeOh1xyXG4gICAgbWFyZ2luUmF0ZSh0b3RhbFZhbHVlKSB7XHJcbiAgICAgIGxldCByaXNrID0gdGhpcy5wcm9kdWN0SW5mbztcclxuICAgICAgbGV0IGluaXRpYWwgPSBOdW1iZXIocmlzay5pbXIpO1xyXG4gICAgICBsZXQgbWFpbnRlbmFuY2UgPSBOdW1iZXIocmlzay5tbXIpO1xyXG4gICAgICBpZiAodG90YWxWYWx1ZSA+IHJpc2sucmlza19saW1pdF9iYXNlKSB7XHJcbiAgICAgICAgbGV0IHN0ZXBzID0gTWF0aC5jZWlsKCh0b3RhbFZhbHVlIC0gcmlzay5yaXNrX2xpbWl0X2Jhc2UpIC8gcmlzay5yaXNrX2xpbWl0X3N0ZXApO1xyXG4gICAgICAgIGluaXRpYWwgPSBVdGlscy5wcmVjaXNpb24udGltZXMoc3RlcHMgKyAxLCBpbml0aWFsKTtcclxuICAgICAgICBtYWludGVuYW5jZSA9IFV0aWxzLnByZWNpc2lvbi50aW1lcyhzdGVwcyArIDEsIG1haW50ZW5hbmNlKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaW5pdGlhbCA+IDEpIHtcclxuICAgICAgICBpbml0aWFsID0gMTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobWFpbnRlbmFuY2UgPiAwLjUpIHtcclxuICAgICAgICBtYWludGVuYW5jZSA9IDAuNTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4ge2luaXRpYWwsIG1haW50ZW5hbmNlfTtcclxuICAgIH0sXHJcbiAgfVxyXG59KTtcclxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n')}]);